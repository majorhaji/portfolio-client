{"ast":null,"code":"/*! firebase-admin v11.5.0 */\n\"use strict\";\n\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\n/** A maximum of 10 test phone number / code pairs can be configured. */\nexports.MAXIMUM_TEST_PHONE_NUMBERS = 10;\n/** Client Auth factor type to server auth factor type mapping. */\nconst AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {\n  phone: 'PHONE_SMS'\n};\n/** Server Auth factor type to client auth factor type mapping. */\nconst AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE).reduce((res, key) => {\n  res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;\n  return res;\n}, {});\n/**\n * Defines the multi-factor config class used to convert client side MultiFactorConfig\n * to a format that is understood by the Auth server.\n */\nclass MultiFactorAuthConfig {\n  /**\n   * The MultiFactorAuthConfig constructor.\n   *\n   * @param response - The server side response used to initialize the\n   *     MultiFactorAuthConfig object.\n   * @constructor\n   * @internal\n   */\n  constructor(response) {\n    if (typeof response.state === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n    }\n    this.state = response.state;\n    this.factorIds = [];\n    (response.enabledProviders || []).forEach(enabledProvider => {\n      // Ignore unsupported types. It is possible the current admin SDK version is\n      // not up to date and newer backend types are supported.\n      if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {\n        this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);\n      }\n    });\n  }\n  /**\n   * Static method to convert a client side request to a MultiFactorAuthServerConfig.\n   * Throws an error if validation fails.\n   *\n   * @param options - The options object to convert to a server request.\n   * @returns The resulting server request.\n   * @internal\n   */\n  static buildServerRequest(options) {\n    const request = {};\n    MultiFactorAuthConfig.validate(options);\n    if (Object.prototype.hasOwnProperty.call(options, 'state')) {\n      request.state = options.state;\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {\n      (options.factorIds || []).forEach(factorId => {\n        if (typeof request.enabledProviders === 'undefined') {\n          request.enabledProviders = [];\n        }\n        request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);\n      });\n      // In case an empty array is passed. Ensure it gets populated so the array is cleared.\n      if (options.factorIds && options.factorIds.length === 0) {\n        request.enabledProviders = [];\n      }\n    }\n    return request;\n  }\n  /**\n   * Validates the MultiFactorConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   */\n  static validate(options) {\n    const validKeys = {\n      state: true,\n      factorIds: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid MultiFactorConfig parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.state !== 'undefined' && options.state !== 'ENABLED' && options.state !== 'DISABLED') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.state\" must be either \"ENABLED\" or \"DISABLED\".');\n    }\n    if (typeof options.factorIds !== 'undefined') {\n      if (!validator.isArray(options.factorIds)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.factorIds\" must be an array of valid \"AuthFactorTypes\".');\n      }\n      // Validate content of array.\n      options.factorIds.forEach(factorId => {\n        if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${factorId}\" is not a valid \"AuthFactorType\".`);\n        }\n      });\n    }\n  }\n  /** @returns The plain object representation of the multi-factor config instance. */\n  toJSON() {\n    return {\n      state: this.state,\n      factorIds: this.factorIds\n    };\n  }\n}\nexports.MultiFactorAuthConfig = MultiFactorAuthConfig;\n/**\n * Validates the provided map of test phone number / code pairs.\n * @param testPhoneNumbers - The phone number / code pairs to validate.\n */\nfunction validateTestPhoneNumbers(testPhoneNumbers) {\n  if (!validator.isObject(testPhoneNumbers)) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"testPhoneNumbers\" must be a map of phone number / code pairs.');\n  }\n  if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {\n    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);\n  }\n  for (const phoneNumber in testPhoneNumbers) {\n    // Validate phone number.\n    if (!validator.isPhoneNumber(phoneNumber)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${phoneNumber}\" is not a valid E.164 standard compliant phone number.`);\n    }\n    // Validate code.\n    if (!validator.isString(testPhoneNumbers[phoneNumber]) || !/^[\\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${testPhoneNumbers[phoneNumber]}\" is not a valid 6 digit code string.`);\n    }\n  }\n}\nexports.validateTestPhoneNumbers = validateTestPhoneNumbers;\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass EmailSignInConfig {\n  /**\n   * The EmailSignInConfig constructor.\n   *\n   * @param response - The server side response used to initialize the\n   *     EmailSignInConfig object.\n   * @constructor\n   */\n  constructor(response) {\n    if (typeof response.allowPasswordSignup === 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n    }\n    this.enabled = response.allowPasswordSignup;\n    this.passwordRequired = !response.enableEmailLinkSignin;\n  }\n  /**\n   * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n   * Throws an error if validation fails.\n   *\n   * @param options - The options object to convert to a server request.\n   * @returns The resulting server request.\n   * @internal\n   */\n  static buildServerRequest(options) {\n    const request = {};\n    EmailSignInConfig.validate(options);\n    if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n      request.allowPasswordSignup = options.enabled;\n    }\n    if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n      request.enableEmailLinkSignin = !options.passwordRequired;\n    }\n    return request;\n  }\n  /**\n   * Validates the EmailSignInConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   */\n  static validate(options) {\n    // TODO: Validate the request.\n    const validKeys = {\n      enabled: true,\n      passwordRequired: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `\"${key}\" is not a valid EmailSignInConfig parameter.`);\n      }\n    }\n    // Validate content.\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n    }\n    if (typeof options.passwordRequired !== 'undefined' && !validator.isBoolean(options.passwordRequired)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n    }\n  }\n  /** @returns The plain object representation of the email sign-in config. */\n  toJSON() {\n    return {\n      enabled: this.enabled,\n      passwordRequired: this.passwordRequired\n    };\n  }\n}\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass SAMLConfig {\n  /**\n   * The SAMLConfig constructor.\n   *\n   * @param response - The server side response used to initialize the SAMLConfig object.\n   * @constructor\n   */\n  constructor(response) {\n    if (!response || !response.idpConfig || !response.idpConfig.idpEntityId || !response.idpConfig.ssoUrl || !response.spConfig || !response.spConfig.spEntityId || !response.name || !(validator.isString(response.name) && SAMLConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n    const providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n    this.providerId = providerId;\n    // RP config.\n    this.rpEntityId = response.spConfig.spEntityId;\n    this.callbackURL = response.spConfig.callbackUri;\n    // IdP config.\n    this.idpEntityId = response.idpConfig.idpEntityId;\n    this.ssoURL = response.idpConfig.ssoUrl;\n    this.enableRequestSigning = !!response.idpConfig.signRequest;\n    const x509Certificates = [];\n    for (const cert of response.idpConfig.idpCertificates || []) {\n      if (cert.x509Certificate) {\n        x509Certificates.push(cert.x509Certificate);\n      }\n    }\n    this.x509Certificates = x509Certificates;\n    // When enabled is undefined, it takes its default value of false.\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n  }\n  /**\n   * Converts a client side request to a SAMLConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a SAMLConfig request,\n   * returns null.\n   *\n   * @param options - The options object to convert to a server request.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   * @returns The resulting server request or null if not valid.\n   */\n  static buildServerRequest(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n    if (!makeRequest) {\n      return null;\n    }\n    const request = {};\n    // Validate options.\n    SAMLConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName;\n    // IdP config.\n    if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n      request.idpConfig = {\n        idpEntityId: options.idpEntityId,\n        ssoUrl: options.ssoURL,\n        signRequest: options.enableRequestSigning,\n        idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : []\n      };\n      if (options.x509Certificates) {\n        for (const cert of options.x509Certificates || []) {\n          request.idpConfig.idpCertificates.push({\n            x509Certificate: cert\n          });\n        }\n      }\n    }\n    // RP config.\n    if (options.callbackURL || options.rpEntityId) {\n      request.spConfig = {\n        spEntityId: options.rpEntityId,\n        callbackUri: options.callbackURL\n      };\n    }\n    return request;\n  }\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param resourceName - The server side resource name.\n   * @returns The provider ID corresponding to the resource, null otherwise.\n   */\n  static getProviderIdFromResourceName(resourceName) {\n    // name is of form projects/project1/inboundSamlConfigs/providerId1\n    const matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n    return matchProviderRes[1];\n  }\n  /**\n   * @param providerId - The provider ID to check.\n   * @returns Whether the provider ID corresponds to a SAML provider.\n   */\n  static isProviderId(providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n  }\n  /**\n   * Validates the SAMLConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   */\n  static validate(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      idpEntityId: true,\n      ssoURL: true,\n      x509Certificates: true,\n      rpEntityId: true,\n      callbackURL: true,\n      enableRequestSigning: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SAML config parameter.`);\n      }\n    }\n    // Required fields.\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('saml.') !== 0) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      // providerId is required and not provided correctly.\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n    }\n    if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') && !validator.isNonEmptyString(options.idpEntityId)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n    }\n    if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') && !validator.isURL(options.ssoURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n    }\n    if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') && !validator.isNonEmptyString(options.rpEntityId)) {\n      throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n    }\n    if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') && !validator.isURL(options.callbackURL)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n    }\n    if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') && !validator.isArray(options.x509Certificates)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n    }\n    (options.x509Certificates || []).forEach(cert => {\n      if (!validator.isNonEmptyString(cert)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n      }\n    });\n    if (typeof options.enableRequestSigning !== 'undefined' && !validator.isBoolean(options.enableRequestSigning)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n    }\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n    }\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n    }\n  }\n  /** @returns The plain object representation of the SAMLConfig. */\n  toJSON() {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      idpEntityId: this.idpEntityId,\n      ssoURL: this.ssoURL,\n      x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),\n      rpEntityId: this.rpEntityId,\n      callbackURL: this.callbackURL,\n      enableRequestSigning: this.enableRequestSigning\n    };\n  }\n}\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass OIDCConfig {\n  /**\n   * The OIDCConfig constructor.\n   *\n   * @param response - The server side response used to initialize the OIDCConfig object.\n   * @constructor\n   */\n  constructor(response) {\n    if (!response || !response.issuer || !response.clientId || !response.name || !(validator.isString(response.name) && OIDCConfig.getProviderIdFromResourceName(response.name))) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n    }\n    const providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n    if (!providerId) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n    }\n    this.providerId = providerId;\n    this.clientId = response.clientId;\n    this.issuer = response.issuer;\n    // When enabled is undefined, it takes its default value of false.\n    this.enabled = !!response.enabled;\n    this.displayName = response.displayName;\n    if (typeof response.clientSecret !== 'undefined') {\n      this.clientSecret = response.clientSecret;\n    }\n    if (typeof response.responseType !== 'undefined') {\n      this.responseType = response.responseType;\n    }\n  }\n  /**\n   * Converts a client side request to a OIDCConfigServerRequest which is the format\n   * accepted by the backend server.\n   * Throws an error if validation fails. If the request is not a OIDCConfig request,\n   * returns null.\n   *\n   * @param options - The options object to convert to a server request.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   * @returns The resulting server request or null if not valid.\n   */\n  static buildServerRequest(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);\n    if (!makeRequest) {\n      return null;\n    }\n    const request = {};\n    // Validate options.\n    OIDCConfig.validate(options, ignoreMissingFields);\n    request.enabled = options.enabled;\n    request.displayName = options.displayName;\n    request.issuer = options.issuer;\n    request.clientId = options.clientId;\n    if (typeof options.clientSecret !== 'undefined') {\n      request.clientSecret = options.clientSecret;\n    }\n    if (typeof options.responseType !== 'undefined') {\n      request.responseType = options.responseType;\n    }\n    return request;\n  }\n  /**\n   * Returns the provider ID corresponding to the resource name if available.\n   *\n   * @param resourceName - The server side resource name\n   * @returns The provider ID corresponding to the resource, null otherwise.\n   */\n  static getProviderIdFromResourceName(resourceName) {\n    // name is of form projects/project1/oauthIdpConfigs/providerId1\n    const matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n    if (!matchProviderRes || matchProviderRes.length < 2) {\n      return null;\n    }\n    return matchProviderRes[1];\n  }\n  /**\n   * @param providerId - The provider ID to check.\n   * @returns Whether the provider ID corresponds to an OIDC provider.\n   */\n  static isProviderId(providerId) {\n    return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n  }\n  /**\n   * Validates the OIDCConfig options object. Throws an error on failure.\n   *\n   * @param options - The options object to validate.\n   * @param ignoreMissingFields - Whether to ignore missing fields.\n   */\n  static validate(options) {\n    let ignoreMissingFields = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const validKeys = {\n      enabled: true,\n      displayName: true,\n      providerId: true,\n      clientId: true,\n      issuer: true,\n      clientSecret: true,\n      responseType: true\n    };\n    const validResponseTypes = {\n      idToken: true,\n      code: true\n    };\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n    }\n    // Check for unsupported top level attributes.\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OIDC config parameter.`);\n      }\n    }\n    // Required fields.\n    if (validator.isNonEmptyString(options.providerId)) {\n      if (options.providerId.indexOf('oidc.') !== 0) {\n        throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n      }\n    } else if (!ignoreMissingFields) {\n      throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n    }\n    if (!(ignoreMissingFields && typeof options.clientId === 'undefined') && !validator.isNonEmptyString(options.clientId)) {\n      throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n    }\n    if (!(ignoreMissingFields && typeof options.issuer === 'undefined') && !validator.isURL(options.issuer)) {\n      throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n    }\n    if (typeof options.enabled !== 'undefined' && !validator.isBoolean(options.enabled)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n    }\n    if (typeof options.displayName !== 'undefined' && !validator.isString(options.displayName)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n    }\n    if (typeof options.clientSecret !== 'undefined' && !validator.isNonEmptyString(options.clientSecret)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.clientSecret\" must be a valid string.');\n    }\n    if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== 'undefined') {\n      Object.keys(options.responseType).forEach(key => {\n        if (!(key in validResponseTypes)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OAuthResponseType parameter.`);\n        }\n      });\n      const idToken = options.responseType.idToken;\n      if (typeof idToken !== 'undefined' && !validator.isBoolean(idToken)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.idToken\" must be a boolean.');\n      }\n      const code = options.responseType.code;\n      if (typeof code !== 'undefined') {\n        if (!validator.isBoolean(code)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.code\" must be a boolean.');\n        }\n        // If code flow is enabled, client secret must be provided.\n        if (code && typeof options.clientSecret === 'undefined') {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, 'The OAuth configuration client secret is required to enable OIDC code flow.');\n        }\n      }\n      const allKeys = Object.keys(options.responseType).length;\n      const enabledCount = Object.values(options.responseType).filter(Boolean).length;\n      // Only one of OAuth response types can be set to true.\n      if (allKeys > 1 && enabledCount != 1) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, 'Only exactly one OAuth responseType should be set to true.');\n      }\n    }\n  }\n  /** @returns The plain object representation of the OIDCConfig. */\n  toJSON() {\n    return {\n      enabled: this.enabled,\n      displayName: this.displayName,\n      providerId: this.providerId,\n      issuer: this.issuer,\n      clientId: this.clientId,\n      clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),\n      responseType: (0, deep_copy_1.deepCopy)(this.responseType)\n    };\n  }\n}\nexports.OIDCConfig = OIDCConfig;\n/**\n * Defines the SMSRegionConfig class used for validation.\n *\n * @internal\n */\nclass SmsRegionsAuthConfig {\n  static validate(options) {\n    if (!validator.isNonNullObject(options)) {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig\" must be a non-null object.');\n    }\n    const validKeys = {\n      allowlistOnly: true,\n      allowByDefault: true\n    };\n    for (const key in options) {\n      if (!(key in validKeys)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig parameter.`);\n      }\n    }\n    // validate mutual exclusiveness of allowByDefault and allowlistOnly\n    if (typeof options.allowByDefault !== 'undefined' && typeof options.allowlistOnly !== 'undefined') {\n      throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both \"allowByDefault\" and \"allowlistOnly\" parameters.');\n    }\n    // validation for allowByDefault type\n    if (typeof options.allowByDefault !== 'undefined') {\n      const allowByDefaultValidKeys = {\n        disallowedRegions: true\n      };\n      for (const key in options.allowByDefault) {\n        if (!(key in allowByDefaultValidKeys)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowByDefault parameter.`);\n        }\n      }\n      // disallowedRegion can be empty.\n      if (typeof options.allowByDefault.disallowedRegions !== 'undefined' && !validator.isArray(options.allowByDefault.disallowedRegions)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowByDefault.disallowedRegions\" must be a valid string array.');\n      }\n    }\n    if (typeof options.allowlistOnly !== 'undefined') {\n      const allowListOnlyValidKeys = {\n        allowedRegions: true\n      };\n      for (const key in options.allowlistOnly) {\n        if (!(key in allowListOnlyValidKeys)) {\n          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowlistOnly parameter.`);\n        }\n      }\n      // allowedRegions can be empty\n      if (typeof options.allowlistOnly.allowedRegions !== 'undefined' && !validator.isArray(options.allowlistOnly.allowedRegions)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowlistOnly.allowedRegions\" must be a valid string array.');\n      }\n    }\n  }\n}\nexports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;","map":{"version":3,"names":["Object","defineProperty","exports","value","SmsRegionsAuthConfig","OIDCConfig","SAMLConfig","EmailSignInConfig","validateTestPhoneNumbers","MultiFactorAuthConfig","MAXIMUM_TEST_PHONE_NUMBERS","validator","require","deep_copy_1","error_1","AUTH_FACTOR_CLIENT_TO_SERVER_TYPE","phone","AUTH_FACTOR_SERVER_TO_CLIENT_TYPE","keys","reduce","res","key","constructor","response","state","FirebaseAuthError","AuthClientErrorCode","INTERNAL_ERROR","factorIds","enabledProviders","forEach","enabledProvider","push","buildServerRequest","options","request","validate","prototype","hasOwnProperty","call","factorId","length","validKeys","isNonNullObject","INVALID_CONFIG","isArray","toJSON","testPhoneNumbers","isObject","INVALID_ARGUMENT","MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED","phoneNumber","isPhoneNumber","INVALID_TESTING_PHONE_NUMBER","isString","test","allowPasswordSignup","enabled","passwordRequired","enableEmailLinkSignin","isBoolean","idpConfig","idpEntityId","ssoUrl","spConfig","spEntityId","name","getProviderIdFromResourceName","providerId","rpEntityId","callbackURL","callbackUri","ssoURL","enableRequestSigning","signRequest","x509Certificates","cert","idpCertificates","x509Certificate","displayName","ignoreMissingFields","makeRequest","undefined","resourceName","matchProviderRes","match","isProviderId","isNonEmptyString","indexOf","INVALID_PROVIDER_ID","MISSING_PROVIDER_ID","isURL","MISSING_SAML_RELYING_PARTY_CONFIG","deepCopy","issuer","clientId","clientSecret","responseType","validResponseTypes","idToken","code","MISSING_OAUTH_CLIENT_ID","INVALID_OAUTH_CLIENT_ID","MISSING_ISSUER","MISSING_OAUTH_CLIENT_SECRET","allKeys","enabledCount","values","filter","Boolean","INVALID_OAUTH_RESPONSETYPE","allowlistOnly","allowByDefault","allowByDefaultValidKeys","disallowedRegions","allowListOnlyValidKeys","allowedRegions"],"sources":["/home/yusuf/coding/portfolio/node_modules/firebase-admin/lib/auth/auth-config.js"],"sourcesContent":["/*! firebase-admin v11.5.0 */\n\"use strict\";\n/*!\n * Copyright 2018 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;\nconst validator = require(\"../utils/validator\");\nconst deep_copy_1 = require(\"../utils/deep-copy\");\nconst error_1 = require(\"../utils/error\");\n/** A maximum of 10 test phone number / code pairs can be configured. */\nexports.MAXIMUM_TEST_PHONE_NUMBERS = 10;\n/** Client Auth factor type to server auth factor type mapping. */\nconst AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {\n    phone: 'PHONE_SMS',\n};\n/** Server Auth factor type to client auth factor type mapping. */\nconst AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE)\n    .reduce((res, key) => {\n    res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;\n    return res;\n}, {});\n/**\n * Defines the multi-factor config class used to convert client side MultiFactorConfig\n * to a format that is understood by the Auth server.\n */\nclass MultiFactorAuthConfig {\n    /**\n     * The MultiFactorAuthConfig constructor.\n     *\n     * @param response - The server side response used to initialize the\n     *     MultiFactorAuthConfig object.\n     * @constructor\n     * @internal\n     */\n    constructor(response) {\n        if (typeof response.state === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid multi-factor configuration response');\n        }\n        this.state = response.state;\n        this.factorIds = [];\n        (response.enabledProviders || []).forEach((enabledProvider) => {\n            // Ignore unsupported types. It is possible the current admin SDK version is\n            // not up to date and newer backend types are supported.\n            if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== 'undefined') {\n                this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);\n            }\n        });\n    }\n    /**\n     * Static method to convert a client side request to a MultiFactorAuthServerConfig.\n     * Throws an error if validation fails.\n     *\n     * @param options - The options object to convert to a server request.\n     * @returns The resulting server request.\n     * @internal\n     */\n    static buildServerRequest(options) {\n        const request = {};\n        MultiFactorAuthConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'state')) {\n            request.state = options.state;\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'factorIds')) {\n            (options.factorIds || []).forEach((factorId) => {\n                if (typeof request.enabledProviders === 'undefined') {\n                    request.enabledProviders = [];\n                }\n                request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);\n            });\n            // In case an empty array is passed. Ensure it gets populated so the array is cleared.\n            if (options.factorIds && options.factorIds.length === 0) {\n                request.enabledProviders = [];\n            }\n        }\n        return request;\n    }\n    /**\n     * Validates the MultiFactorConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     */\n    static validate(options) {\n        const validKeys = {\n            state: true,\n            factorIds: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid MultiFactorConfig parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.state !== 'undefined' &&\n            options.state !== 'ENABLED' &&\n            options.state !== 'DISABLED') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.state\" must be either \"ENABLED\" or \"DISABLED\".');\n        }\n        if (typeof options.factorIds !== 'undefined') {\n            if (!validator.isArray(options.factorIds)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"MultiFactorConfig.factorIds\" must be an array of valid \"AuthFactorTypes\".');\n            }\n            // Validate content of array.\n            options.factorIds.forEach((factorId) => {\n                if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${factorId}\" is not a valid \"AuthFactorType\".`);\n                }\n            });\n        }\n    }\n    /** @returns The plain object representation of the multi-factor config instance. */\n    toJSON() {\n        return {\n            state: this.state,\n            factorIds: this.factorIds,\n        };\n    }\n}\nexports.MultiFactorAuthConfig = MultiFactorAuthConfig;\n/**\n * Validates the provided map of test phone number / code pairs.\n * @param testPhoneNumbers - The phone number / code pairs to validate.\n */\nfunction validateTestPhoneNumbers(testPhoneNumbers) {\n    if (!validator.isObject(testPhoneNumbers)) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"testPhoneNumbers\" must be a map of phone number / code pairs.');\n    }\n    if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {\n        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);\n    }\n    for (const phoneNumber in testPhoneNumbers) {\n        // Validate phone number.\n        if (!validator.isPhoneNumber(phoneNumber)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${phoneNumber}\" is not a valid E.164 standard compliant phone number.`);\n        }\n        // Validate code.\n        if (!validator.isString(testPhoneNumbers[phoneNumber]) ||\n            !/^[\\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `\"${testPhoneNumbers[phoneNumber]}\" is not a valid 6 digit code string.`);\n        }\n    }\n}\nexports.validateTestPhoneNumbers = validateTestPhoneNumbers;\n/**\n * Defines the email sign-in config class used to convert client side EmailSignInConfig\n * to a format that is understood by the Auth server.\n *\n * @internal\n */\nclass EmailSignInConfig {\n    /**\n     * The EmailSignInConfig constructor.\n     *\n     * @param response - The server side response used to initialize the\n     *     EmailSignInConfig object.\n     * @constructor\n     */\n    constructor(response) {\n        if (typeof response.allowPasswordSignup === 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid email sign-in configuration response');\n        }\n        this.enabled = response.allowPasswordSignup;\n        this.passwordRequired = !response.enableEmailLinkSignin;\n    }\n    /**\n     * Static method to convert a client side request to a EmailSignInConfigServerRequest.\n     * Throws an error if validation fails.\n     *\n     * @param options - The options object to convert to a server request.\n     * @returns The resulting server request.\n     * @internal\n     */\n    static buildServerRequest(options) {\n        const request = {};\n        EmailSignInConfig.validate(options);\n        if (Object.prototype.hasOwnProperty.call(options, 'enabled')) {\n            request.allowPasswordSignup = options.enabled;\n        }\n        if (Object.prototype.hasOwnProperty.call(options, 'passwordRequired')) {\n            request.enableEmailLinkSignin = !options.passwordRequired;\n        }\n        return request;\n    }\n    /**\n     * Validates the EmailSignInConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     */\n    static validate(options) {\n        // TODO: Validate the request.\n        const validKeys = {\n            enabled: true,\n            passwordRequired: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig\" must be a non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `\"${key}\" is not a valid EmailSignInConfig parameter.`);\n            }\n        }\n        // Validate content.\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.passwordRequired !== 'undefined' &&\n            !validator.isBoolean(options.passwordRequired)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"EmailSignInConfig.passwordRequired\" must be a boolean.');\n        }\n    }\n    /** @returns The plain object representation of the email sign-in config. */\n    toJSON() {\n        return {\n            enabled: this.enabled,\n            passwordRequired: this.passwordRequired,\n        };\n    }\n}\nexports.EmailSignInConfig = EmailSignInConfig;\n/**\n * Defines the SAMLConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass SAMLConfig {\n    /**\n     * The SAMLConfig constructor.\n     *\n     * @param response - The server side response used to initialize the SAMLConfig object.\n     * @constructor\n     */\n    constructor(response) {\n        if (!response ||\n            !response.idpConfig ||\n            !response.idpConfig.idpEntityId ||\n            !response.idpConfig.ssoUrl ||\n            !response.spConfig ||\n            !response.spConfig.spEntityId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                SAMLConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        const providerId = SAMLConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        // RP config.\n        this.rpEntityId = response.spConfig.spEntityId;\n        this.callbackURL = response.spConfig.callbackUri;\n        // IdP config.\n        this.idpEntityId = response.idpConfig.idpEntityId;\n        this.ssoURL = response.idpConfig.ssoUrl;\n        this.enableRequestSigning = !!response.idpConfig.signRequest;\n        const x509Certificates = [];\n        for (const cert of (response.idpConfig.idpCertificates || [])) {\n            if (cert.x509Certificate) {\n                x509Certificates.push(cert.x509Certificate);\n            }\n        }\n        this.x509Certificates = x509Certificates;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n    }\n    /**\n     * Converts a client side request to a SAMLConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a SAMLConfig request,\n     * returns null.\n     *\n     * @param options - The options object to convert to a server request.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     * @returns The resulting server request or null if not valid.\n     */\n    static buildServerRequest(options, ignoreMissingFields = false) {\n        const makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        const request = {};\n        // Validate options.\n        SAMLConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        // IdP config.\n        if (options.idpEntityId || options.ssoURL || options.x509Certificates) {\n            request.idpConfig = {\n                idpEntityId: options.idpEntityId,\n                ssoUrl: options.ssoURL,\n                signRequest: options.enableRequestSigning,\n                idpCertificates: typeof options.x509Certificates === 'undefined' ? undefined : [],\n            };\n            if (options.x509Certificates) {\n                for (const cert of (options.x509Certificates || [])) {\n                    request.idpConfig.idpCertificates.push({ x509Certificate: cert });\n                }\n            }\n        }\n        // RP config.\n        if (options.callbackURL || options.rpEntityId) {\n            request.spConfig = {\n                spEntityId: options.rpEntityId,\n                callbackUri: options.callbackURL,\n            };\n        }\n        return request;\n    }\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param resourceName - The server side resource name.\n     * @returns The provider ID corresponding to the resource, null otherwise.\n     */\n    static getProviderIdFromResourceName(resourceName) {\n        // name is of form projects/project1/inboundSamlConfigs/providerId1\n        const matchProviderRes = resourceName.match(/\\/inboundSamlConfigs\\/(saml\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    }\n    /**\n     * @param providerId - The provider ID to check.\n     * @returns Whether the provider ID corresponds to a SAML provider.\n     */\n    static isProviderId(providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('saml.') === 0;\n    }\n    /**\n     * Validates the SAMLConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     */\n    static validate(options, ignoreMissingFields = false) {\n        const validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            idpEntityId: true,\n            ssoURL: true,\n            x509Certificates: true,\n            rpEntityId: true,\n            callbackURL: true,\n            enableRequestSigning: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SAML config parameter.`);\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('saml.') !== 0) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            // providerId is required and not provided correctly.\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"SAMLAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"saml.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.idpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.idpEntityId)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.idpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.ssoURL === 'undefined') &&\n            !validator.isURL(options.ssoURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.ssoURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.rpEntityId === 'undefined') &&\n            !validator.isNonEmptyString(options.rpEntityId)) {\n            throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG :\n                error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.rpEntityId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.callbackURL === 'undefined') &&\n            !validator.isURL(options.callbackURL)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.callbackURL\" must be a valid URL string.');\n        }\n        if (!(ignoreMissingFields && typeof options.x509Certificates === 'undefined') &&\n            !validator.isArray(options.x509Certificates)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n        }\n        (options.x509Certificates || []).forEach((cert) => {\n            if (!validator.isNonEmptyString(cert)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.x509Certificates\" must be a valid array of X509 certificate strings.');\n            }\n        });\n        if (typeof options.enableRequestSigning !== 'undefined' &&\n            !validator.isBoolean(options.enableRequestSigning)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enableRequestSigning\" must be a boolean.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SAMLAuthProviderConfig.displayName\" must be a valid string.');\n        }\n    }\n    /** @returns The plain object representation of the SAMLConfig. */\n    toJSON() {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            idpEntityId: this.idpEntityId,\n            ssoURL: this.ssoURL,\n            x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),\n            rpEntityId: this.rpEntityId,\n            callbackURL: this.callbackURL,\n            enableRequestSigning: this.enableRequestSigning,\n        };\n    }\n}\nexports.SAMLConfig = SAMLConfig;\n/**\n * Defines the OIDCConfig class used to convert a client side configuration to its\n * server side representation.\n *\n * @internal\n */\nclass OIDCConfig {\n    /**\n     * The OIDCConfig constructor.\n     *\n     * @param response - The server side response used to initialize the OIDCConfig object.\n     * @constructor\n     */\n    constructor(response) {\n        if (!response ||\n            !response.issuer ||\n            !response.clientId ||\n            !response.name ||\n            !(validator.isString(response.name) &&\n                OIDCConfig.getProviderIdFromResourceName(response.name))) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid OIDC configuration response');\n        }\n        const providerId = OIDCConfig.getProviderIdFromResourceName(response.name);\n        if (!providerId) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, 'INTERNAL ASSERT FAILED: Invalid SAML configuration response');\n        }\n        this.providerId = providerId;\n        this.clientId = response.clientId;\n        this.issuer = response.issuer;\n        // When enabled is undefined, it takes its default value of false.\n        this.enabled = !!response.enabled;\n        this.displayName = response.displayName;\n        if (typeof response.clientSecret !== 'undefined') {\n            this.clientSecret = response.clientSecret;\n        }\n        if (typeof response.responseType !== 'undefined') {\n            this.responseType = response.responseType;\n        }\n    }\n    /**\n     * Converts a client side request to a OIDCConfigServerRequest which is the format\n     * accepted by the backend server.\n     * Throws an error if validation fails. If the request is not a OIDCConfig request,\n     * returns null.\n     *\n     * @param options - The options object to convert to a server request.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     * @returns The resulting server request or null if not valid.\n     */\n    static buildServerRequest(options, ignoreMissingFields = false) {\n        const makeRequest = validator.isNonNullObject(options) &&\n            (options.providerId || ignoreMissingFields);\n        if (!makeRequest) {\n            return null;\n        }\n        const request = {};\n        // Validate options.\n        OIDCConfig.validate(options, ignoreMissingFields);\n        request.enabled = options.enabled;\n        request.displayName = options.displayName;\n        request.issuer = options.issuer;\n        request.clientId = options.clientId;\n        if (typeof options.clientSecret !== 'undefined') {\n            request.clientSecret = options.clientSecret;\n        }\n        if (typeof options.responseType !== 'undefined') {\n            request.responseType = options.responseType;\n        }\n        return request;\n    }\n    /**\n     * Returns the provider ID corresponding to the resource name if available.\n     *\n     * @param resourceName - The server side resource name\n     * @returns The provider ID corresponding to the resource, null otherwise.\n     */\n    static getProviderIdFromResourceName(resourceName) {\n        // name is of form projects/project1/oauthIdpConfigs/providerId1\n        const matchProviderRes = resourceName.match(/\\/oauthIdpConfigs\\/(oidc\\..*)$/);\n        if (!matchProviderRes || matchProviderRes.length < 2) {\n            return null;\n        }\n        return matchProviderRes[1];\n    }\n    /**\n     * @param providerId - The provider ID to check.\n     * @returns Whether the provider ID corresponds to an OIDC provider.\n     */\n    static isProviderId(providerId) {\n        return validator.isNonEmptyString(providerId) && providerId.indexOf('oidc.') === 0;\n    }\n    /**\n     * Validates the OIDCConfig options object. Throws an error on failure.\n     *\n     * @param options - The options object to validate.\n     * @param ignoreMissingFields - Whether to ignore missing fields.\n     */\n    static validate(options, ignoreMissingFields = false) {\n        const validKeys = {\n            enabled: true,\n            displayName: true,\n            providerId: true,\n            clientId: true,\n            issuer: true,\n            clientSecret: true,\n            responseType: true,\n        };\n        const validResponseTypes = {\n            idToken: true,\n            code: true,\n        };\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig\" must be a valid non-null object.');\n        }\n        // Check for unsupported top level attributes.\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OIDC config parameter.`);\n            }\n        }\n        // Required fields.\n        if (validator.isNonEmptyString(options.providerId)) {\n            if (options.providerId.indexOf('oidc.') !== 0) {\n                throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n            }\n        }\n        else if (!ignoreMissingFields) {\n            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '\"OIDCAuthProviderConfig.providerId\" must be a valid non-empty string prefixed with \"oidc.\".');\n        }\n        if (!(ignoreMissingFields && typeof options.clientId === 'undefined') &&\n            !validator.isNonEmptyString(options.clientId)) {\n            throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '\"OIDCAuthProviderConfig.clientId\" must be a valid non-empty string.');\n        }\n        if (!(ignoreMissingFields && typeof options.issuer === 'undefined') &&\n            !validator.isURL(options.issuer)) {\n            throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.issuer\" must be a valid URL string.');\n        }\n        if (typeof options.enabled !== 'undefined' &&\n            !validator.isBoolean(options.enabled)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.enabled\" must be a boolean.');\n        }\n        if (typeof options.displayName !== 'undefined' &&\n            !validator.isString(options.displayName)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.displayName\" must be a valid string.');\n        }\n        if (typeof options.clientSecret !== 'undefined' &&\n            !validator.isNonEmptyString(options.clientSecret)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"OIDCAuthProviderConfig.clientSecret\" must be a valid string.');\n        }\n        if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== 'undefined') {\n            Object.keys(options.responseType).forEach((key) => {\n                if (!(key in validResponseTypes)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid OAuthResponseType parameter.`);\n                }\n            });\n            const idToken = options.responseType.idToken;\n            if (typeof idToken !== 'undefined' && !validator.isBoolean(idToken)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.idToken\" must be a boolean.');\n            }\n            const code = options.responseType.code;\n            if (typeof code !== 'undefined') {\n                if (!validator.isBoolean(code)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '\"OIDCAuthProviderConfig.responseType.code\" must be a boolean.');\n                }\n                // If code flow is enabled, client secret must be provided.\n                if (code && typeof options.clientSecret === 'undefined') {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, 'The OAuth configuration client secret is required to enable OIDC code flow.');\n                }\n            }\n            const allKeys = Object.keys(options.responseType).length;\n            const enabledCount = Object.values(options.responseType).filter(Boolean).length;\n            // Only one of OAuth response types can be set to true.\n            if (allKeys > 1 && enabledCount != 1) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, 'Only exactly one OAuth responseType should be set to true.');\n            }\n        }\n    }\n    /** @returns The plain object representation of the OIDCConfig. */\n    toJSON() {\n        return {\n            enabled: this.enabled,\n            displayName: this.displayName,\n            providerId: this.providerId,\n            issuer: this.issuer,\n            clientId: this.clientId,\n            clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),\n            responseType: (0, deep_copy_1.deepCopy)(this.responseType),\n        };\n    }\n}\nexports.OIDCConfig = OIDCConfig;\n/**\n * Defines the SMSRegionConfig class used for validation.\n *\n * @internal\n */\nclass SmsRegionsAuthConfig {\n    static validate(options) {\n        if (!validator.isNonNullObject(options)) {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig\" must be a non-null object.');\n        }\n        const validKeys = {\n            allowlistOnly: true,\n            allowByDefault: true,\n        };\n        for (const key in options) {\n            if (!(key in validKeys)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig parameter.`);\n            }\n        }\n        // validate mutual exclusiveness of allowByDefault and allowlistOnly\n        if (typeof options.allowByDefault !== 'undefined' && typeof options.allowlistOnly !== 'undefined') {\n            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both \"allowByDefault\" and \"allowlistOnly\" parameters.');\n        }\n        // validation for allowByDefault type\n        if (typeof options.allowByDefault !== 'undefined') {\n            const allowByDefaultValidKeys = {\n                disallowedRegions: true,\n            };\n            for (const key in options.allowByDefault) {\n                if (!(key in allowByDefaultValidKeys)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowByDefault parameter.`);\n                }\n            }\n            // disallowedRegion can be empty.\n            if (typeof options.allowByDefault.disallowedRegions !== 'undefined'\n                && !validator.isArray(options.allowByDefault.disallowedRegions)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowByDefault.disallowedRegions\" must be a valid string array.');\n            }\n        }\n        if (typeof options.allowlistOnly !== 'undefined') {\n            const allowListOnlyValidKeys = {\n                allowedRegions: true,\n            };\n            for (const key in options.allowlistOnly) {\n                if (!(key in allowListOnlyValidKeys)) {\n                    throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `\"${key}\" is not a valid SmsRegionConfig.allowlistOnly parameter.`);\n                }\n            }\n            // allowedRegions can be empty\n            if (typeof options.allowlistOnly.allowedRegions !== 'undefined'\n                && !validator.isArray(options.allowlistOnly.allowedRegions)) {\n                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '\"SmsRegionConfig.allowlistOnly.allowedRegions\" must be a valid string array.');\n            }\n        }\n    }\n}\nexports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;\n"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}