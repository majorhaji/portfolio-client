{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.validateFieldValue = exports.validateDocumentData = exports.validateSetOptions = exports.WriteBatch = exports.WriteResult = void 0;\nconst document_1 = require(\"./document\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst serializer_1 = require(\"./serializer\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class WriteResult\n */\nclass WriteResult {\n  /**\n   * @private\n   *\n   * @param _writeTime The time of the corresponding document write.\n   */\n  constructor(_writeTime) {\n    this._writeTime = _writeTime;\n  }\n  /**\n   * The write time as set by the Firestore servers.\n   *\n   * @type {Timestamp}\n   * @name WriteResult#writeTime\n   * @readonly\n   *\n   * @example\n   * ```\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * documentRef.set({foo: 'bar'}).then(writeResult => {\n   *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\n   * });\n   * ```\n   */\n  get writeTime() {\n    return this._writeTime;\n  }\n  /**\n   * Returns true if this `WriteResult` is equal to the provided value.\n   *\n   * @param {*} other The value to compare against.\n   * @return true if this `WriteResult` is equal to the provided value.\n   */\n  isEqual(other) {\n    return this === other || other instanceof WriteResult && this._writeTime.isEqual(other._writeTime);\n  }\n}\nexports.WriteResult = WriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class WriteBatch\n */\nclass WriteBatch {\n  /** @private */\n  constructor(firestore) {\n    /**\n     * An array of document paths and the corresponding write operations that are\n     * executed as part of the commit. The resulting `api.IWrite` will be sent to\n     * the backend.\n     *\n     * @private\n     * @internal\n     */\n    this._ops = [];\n    this._committed = false;\n    this._firestore = firestore;\n    this._serializer = new serializer_1.Serializer(firestore);\n    this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n  }\n  /**\n   * The number of writes in this batch.\n   * @private\n   */\n  get _opCount() {\n    return this._ops.length;\n  }\n  /**\n   * Checks if this write batch has any pending operations.\n   *\n   * @private\n   * @internal\n   */\n  get isEmpty() {\n    return this._ops.length === 0;\n  }\n  /**\n   * Throws an error if this batch has already been committed.\n   *\n   * @private\n   * @internal\n   */\n  verifyNotCommitted() {\n    if (this._committed) {\n      throw new Error('Cannot modify a WriteBatch that has been committed.');\n    }\n  }\n  /**\n   * Create a document with the provided object values. This will fail the batch\n   * if a document exists at its location.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * created.\n   * @param {T} data The object to serialize as the document.\n   * @throws {Error} If the provided input is not a valid Firestore document.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * ```\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.collection('col').doc();\n   *\n   * writeBatch.create(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   * ```\n   */\n  create(documentRef, data) {\n    const ref = (0, reference_1.validateDocumentReference)('documentRef', documentRef);\n    const firestoreData = ref._converter.toFirestore(data);\n    validateDocumentData('data', firestoreData, /* allowDeletes= */false, this._allowUndefined);\n    this.verifyNotCommitted();\n    const transform = document_1.DocumentTransform.fromObject(ref, firestoreData);\n    transform.validate();\n    const precondition = new document_1.Precondition({\n      exists: false\n    });\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromObject(ref, firestoreData);\n      const write = document.toWriteProto();\n      if (!transform.isEmpty) {\n        write.updateTransforms = transform.toProto(this._serializer);\n      }\n      write.currentDocument = precondition.toProto();\n      return write;\n    };\n    this._ops.push({\n      docPath: documentRef.path,\n      op\n    });\n    return this;\n  }\n  /**\n   * Deletes a document from the database.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * deleted.\n   * @param {Precondition=} precondition A precondition to enforce for this\n   * delete.\n   * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n   * document was last updated at lastUpdateTime. Fails the batch if the\n   * document doesn't exist or was last updated at a different time.\n   * @param {boolean= } precondition.exists If set to true, enforces that the target\n   * document must or must not exist.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * ```\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.delete(documentRef);\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   * ```\n   */\n  delete(documentRef, precondition) {\n    const ref = (0, reference_1.validateDocumentReference)('documentRef', documentRef);\n    validateDeletePrecondition('precondition', precondition, {\n      optional: true\n    });\n    this.verifyNotCommitted();\n    const conditions = new document_1.Precondition(precondition);\n    const op = () => {\n      const write = {\n        delete: ref.formattedName\n      };\n      if (!conditions.isEmpty) {\n        write.currentDocument = conditions.toProto();\n      }\n      return write;\n    };\n    this._ops.push({\n      docPath: documentRef.path,\n      op\n    });\n    return this;\n  }\n  /**\n   * Write to the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document does not\n   * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions},\n   * the provided data can be merged into the existing document.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * set.\n   * @param {T|Partial<T>} data The object to serialize as the document.\n   * @param {SetOptions=} options An object to configure the set behavior.\n   * @param {boolean=} options.merge - If true, set() merges the values\n   * specified in its data argument. Fields omitted from this set() call\n   * remain untouched. If your input sets any field to an empty map, all nested\n   * fields are overwritten.\n   * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n   * set() only replaces the specified field paths. Any field path that is no\n   * specified is ignored and remains untouched. If your input sets any field to\n   * an empty map, all nested fields are overwritten.\n   * @throws {Error} If the provided input is not a valid Firestore document.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * ```\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.set(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   * ```\n   */\n  set(documentRef, data, options) {\n    validateSetOptions('options', options, {\n      optional: true\n    });\n    const mergeLeaves = options && 'merge' in options && options.merge;\n    const mergePaths = options && 'mergeFields' in options;\n    const ref = (0, reference_1.validateDocumentReference)('documentRef', documentRef);\n    let firestoreData;\n    if (mergeLeaves || mergePaths) {\n      // Cast to any in order to satisfy the union type constraint on\n      // toFirestore().\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      firestoreData = ref._converter.toFirestore(data, options);\n    } else {\n      firestoreData = ref._converter.toFirestore(data);\n    }\n    validateDocumentData('data', firestoreData, /* allowDeletes= */!!(mergePaths || mergeLeaves), this._allowUndefined);\n    this.verifyNotCommitted();\n    let documentMask;\n    if (mergePaths) {\n      documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n      firestoreData = documentMask.applyTo(firestoreData);\n    }\n    const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n    transform.validate();\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n      if (mergePaths) {\n        documentMask.removeFields(transform.fields);\n      } else if (mergeLeaves) {\n        documentMask = document_1.DocumentMask.fromObject(firestoreData);\n      }\n      const write = document.toWriteProto();\n      if (!transform.isEmpty) {\n        write.updateTransforms = transform.toProto(this._serializer);\n      }\n      if (mergePaths || mergeLeaves) {\n        write.updateMask = documentMask.toProto();\n      }\n      return write;\n    };\n    this._ops.push({\n      docPath: documentRef.path,\n      op\n    });\n    return this;\n  }\n  /**\n   * Update fields of the document referred to by the provided\n   * [DocumentReference]{@link DocumentReference}. If the document\n   * doesn't yet exist, the update fails and the entire batch will be rejected.\n   *\n   * The update() method accepts either an object with field paths encoded as\n   * keys and field values encoded as values, or a variable number of arguments\n   * that alternate between field paths and field values. Nested fields can be\n   * updated by providing dot-separated field path strings or by providing\n   * FieldPath objects.\n   *\n   * A Precondition restricting this update can be specified as the last\n   * argument.\n   *\n   * @param {DocumentReference} documentRef A reference to the document to be\n   * updated.\n   * @param {UpdateData|string|FieldPath} dataOrField An object\n   * containing the fields and values with which to update the document\n   * or the path of the first field to update.\n   * @param {\n   * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n   * An alternating list of field paths and values to update or a Precondition\n   * to restrict this update.\n   * @throws {Error} If the provided input is not valid Firestore data.\n   * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n   * method calls.\n   *\n   * @example\n   * ```\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.update(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   * ```\n   */\n  update(documentRef, dataOrField) {\n    for (var _len = arguments.length, preconditionOrValues = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      preconditionOrValues[_key - 2] = arguments[_key];\n    }\n    // eslint-disable-next-line prefer-rest-params\n    (0, validate_1.validateMinNumberOfArguments)('WriteBatch.update', arguments, 2);\n    (0, reference_1.validateDocumentReference)('documentRef', documentRef);\n    this.verifyNotCommitted();\n    const updateMap = new Map();\n    let precondition = new document_1.Precondition({\n      exists: true\n    });\n    const argumentError = 'Update() requires either a single JavaScript ' + 'object or an alternating list of field/value pairs that can be ' + 'followed by an optional precondition.';\n    const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n    if (usesVarargs) {\n      const argumentOffset = 1; // Respect 'documentRef' in the error message\n      const fieldOrValues = [dataOrField, ...preconditionOrValues];\n      try {\n        for (let i = 0; i < fieldOrValues.length; i += 2) {\n          if (i === fieldOrValues.length - 1) {\n            const maybePrecondition = fieldOrValues[i];\n            validateUpdatePrecondition(i + argumentOffset, maybePrecondition);\n            precondition = new document_1.Precondition(maybePrecondition);\n          } else {\n            const maybeFieldPath = fieldOrValues[i];\n            (0, path_1.validateFieldPath)(i + argumentOffset, maybeFieldPath);\n            // Unlike the `validateMinNumberOfArguments` invocation above, this\n            // validation can be triggered both from `WriteBatch.update()` and\n            // `DocumentReference.update()`. Hence, we don't use the fully\n            // qualified API name in the error message.\n            (0, validate_1.validateMinNumberOfArguments)('update', fieldOrValues, i + 1);\n            const fieldPath = path_1.FieldPath.fromArgument(maybeFieldPath);\n            validateFieldValue(i + argumentOffset, fieldOrValues[i + 1], this._allowUndefined, fieldPath);\n            updateMap.set(fieldPath, fieldOrValues[i + 1]);\n          }\n        }\n      } catch (err) {\n        (0, logger_1.logger)('WriteBatch.update', null, 'Varargs validation failed:', err);\n        // We catch the validation error here and re-throw to provide a better\n        // error message.\n        throw new Error(`${argumentError} ${err.message}`);\n      }\n    } else {\n      try {\n        validateUpdateMap('dataOrField', dataOrField, this._allowUndefined);\n        // eslint-disable-next-line prefer-rest-params\n        (0, validate_1.validateMaxNumberOfArguments)('update', arguments, 3);\n        Object.entries(dataOrField).forEach(_ref => {\n          let [key, value] = _ref;\n          // Skip `undefined` values (can be hit if `ignoreUndefinedProperties`\n          // is set)\n          if (value !== undefined) {\n            (0, path_1.validateFieldPath)(key, key);\n            updateMap.set(path_1.FieldPath.fromArgument(key), value);\n          }\n        });\n        if (preconditionOrValues.length > 0) {\n          validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n          precondition = new document_1.Precondition(preconditionOrValues[0]);\n        }\n      } catch (err) {\n        (0, logger_1.logger)('WriteBatch.update', null, 'Non-varargs validation failed:', err);\n        // We catch the validation error here and prefix the error with a custom\n        // message to describe the usage of update() better.\n        throw new Error(`${argumentError} ${err.message}`);\n      }\n    }\n    validateNoConflictingFields('dataOrField', updateMap);\n    const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n    transform.validate();\n    const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n    const op = () => {\n      const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n      const write = document.toWriteProto();\n      write.updateMask = documentMask.toProto();\n      if (!transform.isEmpty) {\n        write.updateTransforms = transform.toProto(this._serializer);\n      }\n      write.currentDocument = precondition.toProto();\n      return write;\n    };\n    this._ops.push({\n      docPath: documentRef.path,\n      op\n    });\n    return this;\n  }\n  /**\n   * Atomically commits all pending operations to the database and verifies all\n   * preconditions. Fails the entire write if any precondition is not met.\n   *\n   * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n   * when this batch completes.\n   *\n   * @example\n   * ```\n   * let writeBatch = firestore.batch();\n   * let documentRef = firestore.doc('col/doc');\n   *\n   * writeBatch.set(documentRef, {foo: 'bar'});\n   *\n   * writeBatch.commit().then(() => {\n   *   console.log('Successfully executed batch.');\n   * });\n   * ```\n   */\n  commit() {\n    // Capture the error stack to preserve stack tracing across async calls.\n    const stack = Error().stack;\n    // Commits should also be retried when they fail with status code ABORTED.\n    const retryCodes = [10 /* StatusCode.ABORTED */, ...(0, util_1.getRetryCodes)('commit')];\n    return this._commit({\n      retryCodes\n    }).then(response => {\n      return (response.writeResults || []).map(writeResult => new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime)));\n    }).catch(err => {\n      throw (0, util_1.wrapError)(err, stack);\n    });\n  }\n  /**\n   * Commit method that takes an optional transaction ID.\n   *\n   * @private\n   * @internal\n   * @param commitOptions Options to use for this commit.\n   * @param commitOptions.transactionId The transaction ID of this commit.\n   * @param commitOptions.requestTag A unique client-assigned identifier for\n   * this request.\n   * @returns  A Promise that resolves when this batch completes.\n   */\n  async _commit(commitOptions) {\n    var _a;\n    // Note: We don't call `verifyNotCommitted()` to allow for retries.\n    this._committed = true;\n    const tag = (_a = commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.requestTag) !== null && _a !== void 0 ? _a : (0, util_1.requestTag)();\n    await this._firestore.initializeIfNeeded(tag);\n    // Note that the request may not always be of type ICommitRequest. This is\n    // just here to ensure type safety.\n    const request = {\n      database: this._firestore.formattedName,\n      writes: this._ops.map(op => op.op())\n    };\n    if (commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.transactionId) {\n      request.transaction = commitOptions.transactionId;\n    }\n    (0, logger_1.logger)('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n    return this._firestore.request((commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.methodName) || 'commit', request, tag, commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.retryCodes);\n  }\n  /**\n   * Resets the WriteBatch and dequeues all pending operations.\n   * @private\n   * @internal\n   */\n  _reset() {\n    this._ops.splice(0);\n    this._committed = false;\n  }\n}\nexports.WriteBatch = WriteBatch;\n/**\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate\n * @param allowExists Whether to allow the 'exists' preconditions.\n */\nfunction validatePrecondition(arg, value, allowExists) {\n  if (typeof value !== 'object' || value === null) {\n    throw new Error('Input is not an object.');\n  }\n  const precondition = value;\n  let conditions = 0;\n  if (precondition.exists !== undefined) {\n    ++conditions;\n    if (!allowExists) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} \"exists\" is not an allowed precondition.`);\n    }\n    if (typeof precondition.exists !== 'boolean') {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} \"exists\" is not a boolean.'`);\n    }\n  }\n  if (precondition.lastUpdateTime !== undefined) {\n    ++conditions;\n    if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} \"lastUpdateTime\" is not a Firestore Timestamp.`);\n    }\n  }\n  if (conditions > 1) {\n    throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} Input specifies more than one precondition.`);\n  }\n}\n/**\n * Validates the use of 'value' as an update Precondition.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateUpdatePrecondition(arg, value, options) {\n  if (!(0, validate_1.validateOptional)(value, options)) {\n    validatePrecondition(arg, value, /* allowExists= */false);\n  }\n}\n/**\n * Validates the use of 'value' as a delete Precondition.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateDeletePrecondition(arg, value, options) {\n  if (!(0, validate_1.validateOptional)(value, options)) {\n    validatePrecondition(arg, value, /* allowExists= */true);\n  }\n}\n/**\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n * @throws if the input is not a valid SetOptions object.\n */\nfunction validateSetOptions(arg, value, options) {\n  if (!(0, validate_1.validateOptional)(value, options)) {\n    if (!(0, util_1.isObject)(value)) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'set() options argument')} Input is not an object.`);\n    }\n    const setOptions = value;\n    if ('mergeFields' in setOptions) {\n      for (let i = 0; i < setOptions.mergeFields.length; ++i) {\n        try {\n          (0, path_1.validateFieldPath)(i, setOptions.mergeFields[i]);\n        } catch (err) {\n          throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'set() options argument')} \"mergeFields\" is not valid: ${err.message}`);\n        }\n      }\n    }\n    if ('merge' in setOptions && 'mergeFields' in setOptions) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'set() options argument')} You cannot specify both \"merge\" and \"mergeFields\".`);\n    }\n  }\n}\nexports.validateSetOptions = validateSetOptions;\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\n  if (!(0, util_1.isPlainObject)(obj)) {\n    throw new Error((0, validate_1.customObjectMessage)(arg, obj));\n  }\n  (0, serializer_1.validateUserInput)(arg, obj, 'Firestore document', {\n    allowDeletes: allowDeletes ? 'all' : 'none',\n    allowTransforms: true,\n    allowUndefined\n  });\n}\nexports.validateDocumentData = validateDocumentData;\n/**\n * Validates that a value can be used as field value during an update.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param val The value to verify.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @param path The path to show in the error message.\n */\nfunction validateFieldValue(arg, val, allowUndefined, path) {\n  (0, serializer_1.validateUserInput)(arg, val, 'Firestore value', {\n    allowDeletes: 'root',\n    allowTransforms: true,\n    allowUndefined\n  }, path);\n}\nexports.validateFieldValue = validateFieldValue;\n/**\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param data An update map with field/value pairs.\n */\nfunction validateNoConflictingFields(arg, data) {\n  const fields = [];\n  data.forEach((value, key) => {\n    fields.push(key);\n  });\n  fields.sort((left, right) => left.compareTo(right));\n  for (let i = 1; i < fields.length; ++i) {\n    if (fields[i - 1].isPrefixOf(fields[i])) {\n      throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'update map')} Field \"${fields[i - 1]}\" was specified multiple times.`);\n    }\n  }\n}\n/**\n * Validates that a JavaScript object is a map of field paths to field values.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateUpdateMap(arg, obj, allowUndefined) {\n  if (!(0, util_1.isPlainObject)(obj)) {\n    throw new Error((0, validate_1.customObjectMessage)(arg, obj));\n  }\n  if (Object.keys(obj).length === 0) {\n    throw new Error('At least one field must be updated.');\n  }\n  validateFieldValue(arg, obj, allowUndefined);\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","validateFieldValue","validateDocumentData","validateSetOptions","WriteBatch","WriteResult","document_1","require","logger_1","path_1","reference_1","serializer_1","timestamp_1","util_1","validate_1","constructor","_writeTime","writeTime","isEqual","other","firestore","_ops","_committed","_firestore","_serializer","Serializer","_allowUndefined","_settings","ignoreUndefinedProperties","_opCount","length","isEmpty","verifyNotCommitted","Error","create","documentRef","data","ref","validateDocumentReference","firestoreData","_converter","toFirestore","transform","DocumentTransform","fromObject","validate","precondition","Precondition","exists","op","document","DocumentSnapshot","write","toWriteProto","updateTransforms","toProto","currentDocument","push","docPath","path","delete","validateDeletePrecondition","optional","conditions","formattedName","set","options","mergeLeaves","merge","mergePaths","documentMask","DocumentMask","fromFieldMask","mergeFields","applyTo","removeFields","fields","updateMask","update","dataOrField","preconditionOrValues","validateMinNumberOfArguments","arguments","updateMap","Map","argumentError","usesVarargs","FieldPath","argumentOffset","fieldOrValues","i","maybePrecondition","validateUpdatePrecondition","maybeFieldPath","validateFieldPath","fieldPath","fromArgument","err","logger","message","validateUpdateMap","validateMaxNumberOfArguments","entries","forEach","key","undefined","validateNoConflictingFields","fromUpdateMap","commit","stack","retryCodes","getRetryCodes","_commit","then","response","writeResults","map","writeResult","Timestamp","fromProto","updateTime","commitTime","catch","wrapError","commitOptions","_a","tag","requestTag","initializeIfNeeded","request","database","writes","transactionId","transaction","methodName","_reset","splice","validatePrecondition","arg","allowExists","invalidArgumentMessage","lastUpdateTime","validateOptional","isObject","setOptions","obj","allowDeletes","allowUndefined","isPlainObject","customObjectMessage","validateUserInput","allowTransforms","val","sort","left","right","compareTo","isPrefixOf","keys"],"sources":["/home/yusuf/coding/portfolio/node_modules/@google-cloud/firestore/build/src/write-batch.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2019 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.validateFieldValue = exports.validateDocumentData = exports.validateSetOptions = exports.WriteBatch = exports.WriteResult = void 0;\nconst document_1 = require(\"./document\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst reference_1 = require(\"./reference\");\nconst serializer_1 = require(\"./serializer\");\nconst timestamp_1 = require(\"./timestamp\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\n/**\n * A WriteResult wraps the write time set by the Firestore servers on sets(),\n * updates(), and creates().\n *\n * @class WriteResult\n */\nclass WriteResult {\n    /**\n     * @private\n     *\n     * @param _writeTime The time of the corresponding document write.\n     */\n    constructor(_writeTime) {\n        this._writeTime = _writeTime;\n    }\n    /**\n     * The write time as set by the Firestore servers.\n     *\n     * @type {Timestamp}\n     * @name WriteResult#writeTime\n     * @readonly\n     *\n     * @example\n     * ```\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(writeResult => {\n     *   console.log(`Document written at: ${writeResult.writeTime.toDate()}`);\n     * });\n     * ```\n     */\n    get writeTime() {\n        return this._writeTime;\n    }\n    /**\n     * Returns true if this `WriteResult` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return true if this `WriteResult` is equal to the provided value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof WriteResult &&\n                this._writeTime.isEqual(other._writeTime)));\n    }\n}\nexports.WriteResult = WriteResult;\n/**\n * A Firestore WriteBatch that can be used to atomically commit multiple write\n * operations at once.\n *\n * @class WriteBatch\n */\nclass WriteBatch {\n    /** @private */\n    constructor(firestore) {\n        /**\n         * An array of document paths and the corresponding write operations that are\n         * executed as part of the commit. The resulting `api.IWrite` will be sent to\n         * the backend.\n         *\n         * @private\n         * @internal\n         */\n        this._ops = [];\n        this._committed = false;\n        this._firestore = firestore;\n        this._serializer = new serializer_1.Serializer(firestore);\n        this._allowUndefined = !!firestore._settings.ignoreUndefinedProperties;\n    }\n    /**\n     * The number of writes in this batch.\n     * @private\n     */\n    get _opCount() {\n        return this._ops.length;\n    }\n    /**\n     * Checks if this write batch has any pending operations.\n     *\n     * @private\n     * @internal\n     */\n    get isEmpty() {\n        return this._ops.length === 0;\n    }\n    /**\n     * Throws an error if this batch has already been committed.\n     *\n     * @private\n     * @internal\n     */\n    verifyNotCommitted() {\n        if (this._committed) {\n            throw new Error('Cannot modify a WriteBatch that has been committed.');\n        }\n    }\n    /**\n     * Create a document with the provided object values. This will fail the batch\n     * if a document exists at its location.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * created.\n     * @param {T} data The object to serialize as the document.\n     * @throws {Error} If the provided input is not a valid Firestore document.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * ```\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * writeBatch.create(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     * ```\n     */\n    create(documentRef, data) {\n        const ref = (0, reference_1.validateDocumentReference)('documentRef', documentRef);\n        const firestoreData = ref._converter.toFirestore(data);\n        validateDocumentData('data', firestoreData, \n        /* allowDeletes= */ false, this._allowUndefined);\n        this.verifyNotCommitted();\n        const transform = document_1.DocumentTransform.fromObject(ref, firestoreData);\n        transform.validate();\n        const precondition = new document_1.Precondition({ exists: false });\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromObject(ref, firestoreData);\n            const write = document.toWriteProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            write.currentDocument = precondition.toProto();\n            return write;\n        };\n        this._ops.push({ docPath: documentRef.path, op });\n        return this;\n    }\n    /**\n     * Deletes a document from the database.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * deleted.\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the batch if the\n     * document doesn't exist or was last updated at a different time.\n     * @param {boolean= } precondition.exists If set to true, enforces that the target\n     * document must or must not exist.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * ```\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.delete(documentRef);\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     * ```\n     */\n    delete(documentRef, precondition) {\n        const ref = (0, reference_1.validateDocumentReference)('documentRef', documentRef);\n        validateDeletePrecondition('precondition', precondition, { optional: true });\n        this.verifyNotCommitted();\n        const conditions = new document_1.Precondition(precondition);\n        const op = () => {\n            const write = { delete: ref.formattedName };\n            if (!conditions.isEmpty) {\n                write.currentDocument = conditions.toProto();\n            }\n            return write;\n        };\n        this._ops.push({ docPath: documentRef.path, op });\n        return this;\n    }\n    /**\n     * Write to the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document does not\n     * exist yet, it will be created. If you pass [SetOptions]{@link SetOptions},\n     * the provided data can be merged into the existing document.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * set.\n     * @param {T|Partial<T>} data The object to serialize as the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge - If true, set() merges the values\n     * specified in its data argument. Fields omitted from this set() call\n     * remain untouched. If your input sets any field to an empty map, all nested\n     * fields are overwritten.\n     * @param {Array.<string|FieldPath>=} options.mergeFields - If provided,\n     * set() only replaces the specified field paths. Any field path that is no\n     * specified is ignored and remains untouched. If your input sets any field to\n     * an empty map, all nested fields are overwritten.\n     * @throws {Error} If the provided input is not a valid Firestore document.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * ```\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     * ```\n     */\n    set(documentRef, data, options) {\n        validateSetOptions('options', options, { optional: true });\n        const mergeLeaves = options && 'merge' in options && options.merge;\n        const mergePaths = options && 'mergeFields' in options;\n        const ref = (0, reference_1.validateDocumentReference)('documentRef', documentRef);\n        let firestoreData;\n        if (mergeLeaves || mergePaths) {\n            // Cast to any in order to satisfy the union type constraint on\n            // toFirestore().\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            firestoreData = ref._converter.toFirestore(data, options);\n        }\n        else {\n            firestoreData = ref._converter.toFirestore(data);\n        }\n        validateDocumentData('data', firestoreData, \n        /* allowDeletes= */ !!(mergePaths || mergeLeaves), this._allowUndefined);\n        this.verifyNotCommitted();\n        let documentMask;\n        if (mergePaths) {\n            documentMask = document_1.DocumentMask.fromFieldMask(options.mergeFields);\n            firestoreData = documentMask.applyTo(firestoreData);\n        }\n        const transform = document_1.DocumentTransform.fromObject(documentRef, firestoreData);\n        transform.validate();\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromObject(documentRef, firestoreData);\n            if (mergePaths) {\n                documentMask.removeFields(transform.fields);\n            }\n            else if (mergeLeaves) {\n                documentMask = document_1.DocumentMask.fromObject(firestoreData);\n            }\n            const write = document.toWriteProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            if (mergePaths || mergeLeaves) {\n                write.updateMask = documentMask.toProto();\n            }\n            return write;\n        };\n        this._ops.push({ docPath: documentRef.path, op });\n        return this;\n    }\n    /**\n     * Update fields of the document referred to by the provided\n     * [DocumentReference]{@link DocumentReference}. If the document\n     * doesn't yet exist, the update fails and the entire batch will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values. Nested fields can be\n     * updated by providing dot-separated field path strings or by providing\n     * FieldPath objects.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {DocumentReference} documentRef A reference to the document to be\n     * updated.\n     * @param {UpdateData|string|FieldPath} dataOrField An object\n     * containing the fields and values with which to update the document\n     * or the path of the first field to update.\n     * @param {\n     * ...(Precondition|*|string|FieldPath)} preconditionOrValues -\n     * An alternating list of field paths and values to update or a Precondition\n     * to restrict this update.\n     * @throws {Error} If the provided input is not valid Firestore data.\n     * @returns {WriteBatch} This WriteBatch instance. Used for chaining\n     * method calls.\n     *\n     * @example\n     * ```\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.update(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     * ```\n     */\n    update(documentRef, dataOrField, ...preconditionOrValues) {\n        // eslint-disable-next-line prefer-rest-params\n        (0, validate_1.validateMinNumberOfArguments)('WriteBatch.update', arguments, 2);\n        (0, reference_1.validateDocumentReference)('documentRef', documentRef);\n        this.verifyNotCommitted();\n        const updateMap = new Map();\n        let precondition = new document_1.Precondition({ exists: true });\n        const argumentError = 'Update() requires either a single JavaScript ' +\n            'object or an alternating list of field/value pairs that can be ' +\n            'followed by an optional precondition.';\n        const usesVarargs = typeof dataOrField === 'string' || dataOrField instanceof path_1.FieldPath;\n        if (usesVarargs) {\n            const argumentOffset = 1; // Respect 'documentRef' in the error message\n            const fieldOrValues = [dataOrField, ...preconditionOrValues];\n            try {\n                for (let i = 0; i < fieldOrValues.length; i += 2) {\n                    if (i === fieldOrValues.length - 1) {\n                        const maybePrecondition = fieldOrValues[i];\n                        validateUpdatePrecondition(i + argumentOffset, maybePrecondition);\n                        precondition = new document_1.Precondition(maybePrecondition);\n                    }\n                    else {\n                        const maybeFieldPath = fieldOrValues[i];\n                        (0, path_1.validateFieldPath)(i + argumentOffset, maybeFieldPath);\n                        // Unlike the `validateMinNumberOfArguments` invocation above, this\n                        // validation can be triggered both from `WriteBatch.update()` and\n                        // `DocumentReference.update()`. Hence, we don't use the fully\n                        // qualified API name in the error message.\n                        (0, validate_1.validateMinNumberOfArguments)('update', fieldOrValues, i + 1);\n                        const fieldPath = path_1.FieldPath.fromArgument(maybeFieldPath);\n                        validateFieldValue(i + argumentOffset, fieldOrValues[i + 1], this._allowUndefined, fieldPath);\n                        updateMap.set(fieldPath, fieldOrValues[i + 1]);\n                    }\n                }\n            }\n            catch (err) {\n                (0, logger_1.logger)('WriteBatch.update', null, 'Varargs validation failed:', err);\n                // We catch the validation error here and re-throw to provide a better\n                // error message.\n                throw new Error(`${argumentError} ${err.message}`);\n            }\n        }\n        else {\n            try {\n                validateUpdateMap('dataOrField', dataOrField, this._allowUndefined);\n                // eslint-disable-next-line prefer-rest-params\n                (0, validate_1.validateMaxNumberOfArguments)('update', arguments, 3);\n                Object.entries(dataOrField).forEach(([key, value]) => {\n                    // Skip `undefined` values (can be hit if `ignoreUndefinedProperties`\n                    // is set)\n                    if (value !== undefined) {\n                        (0, path_1.validateFieldPath)(key, key);\n                        updateMap.set(path_1.FieldPath.fromArgument(key), value);\n                    }\n                });\n                if (preconditionOrValues.length > 0) {\n                    validateUpdatePrecondition('preconditionOrValues', preconditionOrValues[0]);\n                    precondition = new document_1.Precondition(preconditionOrValues[0]);\n                }\n            }\n            catch (err) {\n                (0, logger_1.logger)('WriteBatch.update', null, 'Non-varargs validation failed:', err);\n                // We catch the validation error here and prefix the error with a custom\n                // message to describe the usage of update() better.\n                throw new Error(`${argumentError} ${err.message}`);\n            }\n        }\n        validateNoConflictingFields('dataOrField', updateMap);\n        const transform = document_1.DocumentTransform.fromUpdateMap(documentRef, updateMap);\n        transform.validate();\n        const documentMask = document_1.DocumentMask.fromUpdateMap(updateMap);\n        const op = () => {\n            const document = document_1.DocumentSnapshot.fromUpdateMap(documentRef, updateMap);\n            const write = document.toWriteProto();\n            write.updateMask = documentMask.toProto();\n            if (!transform.isEmpty) {\n                write.updateTransforms = transform.toProto(this._serializer);\n            }\n            write.currentDocument = precondition.toProto();\n            return write;\n        };\n        this._ops.push({ docPath: documentRef.path, op });\n        return this;\n    }\n    /**\n     * Atomically commits all pending operations to the database and verifies all\n     * preconditions. Fails the entire write if any precondition is not met.\n     *\n     * @returns {Promise.<Array.<WriteResult>>} A Promise that resolves\n     * when this batch completes.\n     *\n     * @example\n     * ```\n     * let writeBatch = firestore.batch();\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * writeBatch.set(documentRef, {foo: 'bar'});\n     *\n     * writeBatch.commit().then(() => {\n     *   console.log('Successfully executed batch.');\n     * });\n     * ```\n     */\n    commit() {\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        // Commits should also be retried when they fail with status code ABORTED.\n        const retryCodes = [10 /* StatusCode.ABORTED */, ...(0, util_1.getRetryCodes)('commit')];\n        return this._commit({ retryCodes })\n            .then(response => {\n            return (response.writeResults || []).map(writeResult => new WriteResult(timestamp_1.Timestamp.fromProto(writeResult.updateTime || response.commitTime)));\n        })\n            .catch(err => {\n            throw (0, util_1.wrapError)(err, stack);\n        });\n    }\n    /**\n     * Commit method that takes an optional transaction ID.\n     *\n     * @private\n     * @internal\n     * @param commitOptions Options to use for this commit.\n     * @param commitOptions.transactionId The transaction ID of this commit.\n     * @param commitOptions.requestTag A unique client-assigned identifier for\n     * this request.\n     * @returns  A Promise that resolves when this batch completes.\n     */\n    async _commit(commitOptions) {\n        var _a;\n        // Note: We don't call `verifyNotCommitted()` to allow for retries.\n        this._committed = true;\n        const tag = (_a = commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.requestTag) !== null && _a !== void 0 ? _a : (0, util_1.requestTag)();\n        await this._firestore.initializeIfNeeded(tag);\n        // Note that the request may not always be of type ICommitRequest. This is\n        // just here to ensure type safety.\n        const request = {\n            database: this._firestore.formattedName,\n            writes: this._ops.map(op => op.op()),\n        };\n        if (commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.transactionId) {\n            request.transaction = commitOptions.transactionId;\n        }\n        (0, logger_1.logger)('WriteBatch.commit', tag, 'Sending %d writes', request.writes.length);\n        return this._firestore.request((commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.methodName) || 'commit', request, tag, commitOptions === null || commitOptions === void 0 ? void 0 : commitOptions.retryCodes);\n    }\n    /**\n     * Resets the WriteBatch and dequeues all pending operations.\n     * @private\n     * @internal\n     */\n    _reset() {\n        this._ops.splice(0);\n        this._committed = false;\n    }\n}\nexports.WriteBatch = WriteBatch;\n/**\n * Validates the use of 'value' as a Precondition and enforces that 'exists'\n * and 'lastUpdateTime' use valid types.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate\n * @param allowExists Whether to allow the 'exists' preconditions.\n */\nfunction validatePrecondition(arg, value, allowExists) {\n    if (typeof value !== 'object' || value === null) {\n        throw new Error('Input is not an object.');\n    }\n    const precondition = value;\n    let conditions = 0;\n    if (precondition.exists !== undefined) {\n        ++conditions;\n        if (!allowExists) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} \"exists\" is not an allowed precondition.`);\n        }\n        if (typeof precondition.exists !== 'boolean') {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} \"exists\" is not a boolean.'`);\n        }\n    }\n    if (precondition.lastUpdateTime !== undefined) {\n        ++conditions;\n        if (!(precondition.lastUpdateTime instanceof timestamp_1.Timestamp)) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} \"lastUpdateTime\" is not a Firestore Timestamp.`);\n        }\n    }\n    if (conditions > 1) {\n        throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'precondition')} Input specifies more than one precondition.`);\n    }\n}\n/**\n * Validates the use of 'value' as an update Precondition.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateUpdatePrecondition(arg, value, options) {\n    if (!(0, validate_1.validateOptional)(value, options)) {\n        validatePrecondition(arg, value, /* allowExists= */ false);\n    }\n}\n/**\n * Validates the use of 'value' as a delete Precondition.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n */\nfunction validateDeletePrecondition(arg, value, options) {\n    if (!(0, validate_1.validateOptional)(value, options)) {\n        validatePrecondition(arg, value, /* allowExists= */ true);\n    }\n}\n/**\n * Validates the use of 'value' as SetOptions and enforces that 'merge' is a\n * boolean.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The object to validate.\n * @param options Optional validation options specifying whether the value can\n * be omitted.\n * @throws if the input is not a valid SetOptions object.\n */\nfunction validateSetOptions(arg, value, options) {\n    if (!(0, validate_1.validateOptional)(value, options)) {\n        if (!(0, util_1.isObject)(value)) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'set() options argument')} Input is not an object.`);\n        }\n        const setOptions = value;\n        if ('mergeFields' in setOptions) {\n            for (let i = 0; i < setOptions.mergeFields.length; ++i) {\n                try {\n                    (0, path_1.validateFieldPath)(i, setOptions.mergeFields[i]);\n                }\n                catch (err) {\n                    throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'set() options argument')} \"mergeFields\" is not valid: ${err.message}`);\n                }\n            }\n        }\n        if ('merge' in setOptions && 'mergeFields' in setOptions) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'set() options argument')} You cannot specify both \"merge\" and \"mergeFields\".`);\n        }\n    }\n}\nexports.validateSetOptions = validateSetOptions;\n/**\n * Validates a JavaScript object for usage as a Firestore document.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowDeletes Whether to allow FieldValue.delete() sentinels.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateDocumentData(arg, obj, allowDeletes, allowUndefined) {\n    if (!(0, util_1.isPlainObject)(obj)) {\n        throw new Error((0, validate_1.customObjectMessage)(arg, obj));\n    }\n    (0, serializer_1.validateUserInput)(arg, obj, 'Firestore document', {\n        allowDeletes: allowDeletes ? 'all' : 'none',\n        allowTransforms: true,\n        allowUndefined,\n    });\n}\nexports.validateDocumentData = validateDocumentData;\n/**\n * Validates that a value can be used as field value during an update.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param val The value to verify.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @param path The path to show in the error message.\n */\nfunction validateFieldValue(arg, val, allowUndefined, path) {\n    (0, serializer_1.validateUserInput)(arg, val, 'Firestore value', { allowDeletes: 'root', allowTransforms: true, allowUndefined }, path);\n}\nexports.validateFieldValue = validateFieldValue;\n/**\n * Validates that the update data does not contain any ambiguous field\n * definitions (such as 'a.b' and 'a').\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param data An update map with field/value pairs.\n */\nfunction validateNoConflictingFields(arg, data) {\n    const fields = [];\n    data.forEach((value, key) => {\n        fields.push(key);\n    });\n    fields.sort((left, right) => left.compareTo(right));\n    for (let i = 1; i < fields.length; ++i) {\n        if (fields[i - 1].isPrefixOf(fields[i])) {\n            throw new Error(`${(0, validate_1.invalidArgumentMessage)(arg, 'update map')} Field \"${fields[i - 1]}\" was specified multiple times.`);\n        }\n    }\n}\n/**\n * Validates that a JavaScript object is a map of field paths to field values.\n *\n * @private\n * @internal\n * @param arg The argument name or argument index (for varargs methods).\n * @param obj JavaScript object to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n * @throws when the object is invalid.\n */\nfunction validateUpdateMap(arg, obj, allowUndefined) {\n    if (!(0, util_1.isPlainObject)(obj)) {\n        throw new Error((0, validate_1.customObjectMessage)(arg, obj));\n    }\n    if (Object.keys(obj).length === 0) {\n        throw new Error('At least one field must be updated.');\n    }\n    validateFieldValue(arg, obj, allowUndefined);\n}\n//# sourceMappingURL=write-batch.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}