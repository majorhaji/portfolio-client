{"ast":null,"code":"\"use strict\";\n\n/*!\n * Copyright 2022 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.util = exports.Util = exports.PartialFailureError = exports.ApiError = void 0;\n/*!\n * @module common/util\n */\nconst projectify_1 = require(\"@google-cloud/projectify\");\nconst ent = require(\"ent\");\nconst extend = require(\"extend\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst retryRequest = require(\"retry-request\");\nconst stream_1 = require(\"stream\");\nconst teeny_request_1 = require(\"teeny-request\");\nconst uuid = require(\"uuid\");\nconst service_1 = require(\"./service\");\nconst packageJson = require('../../../package.json');\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = require('duplexify');\nconst requestDefaults = {\n  timeout: 60000,\n  gzip: true,\n  forever: true,\n  pool: {\n    maxSockets: Infinity\n  }\n};\n/**\n * Default behavior: Automatically retry retriable server errors.\n *\n * @const {boolean}\n * @private\n */\nconst AUTO_RETRY_DEFAULT = true;\n/**\n * Default behavior: Only attempt to retry retriable errors 3 times.\n *\n * @const {number}\n * @private\n */\nconst MAX_RETRY_DEFAULT = 3;\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\nclass ApiError extends Error {\n  constructor(errorBodyOrMessage) {\n    super();\n    if (typeof errorBodyOrMessage !== 'object') {\n      this.message = errorBodyOrMessage || '';\n      return;\n    }\n    const errorBody = errorBodyOrMessage;\n    this.code = errorBody.code;\n    this.errors = errorBody.errors;\n    this.response = errorBody.response;\n    try {\n      this.errors = JSON.parse(this.response.body).error.errors;\n    } catch (e) {\n      this.errors = errorBody.errors;\n    }\n    this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);\n    Error.captureStackTrace(this);\n  }\n  /**\n   * Pieces together an error message by combining all unique error messages\n   * returned from a single GoogleError\n   *\n   * @private\n   *\n   * @param {GoogleErrorBody} err The original error.\n   * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n   * @returns {string}\n   */\n  static createMultiErrorMessage(err, errors) {\n    const messages = new Set();\n    if (err.message) {\n      messages.add(err.message);\n    }\n    if (errors && errors.length) {\n      errors.forEach(_ref => {\n        let {\n          message\n        } = _ref;\n        return messages.add(message);\n      });\n    } else if (err.response && err.response.body) {\n      messages.add(ent.decode(err.response.body.toString()));\n    } else if (!err.message) {\n      messages.add('A failure occurred during this request.');\n    }\n    let messageArr = Array.from(messages);\n    if (messageArr.length > 1) {\n      messageArr = messageArr.map((message, i) => `    ${i + 1}. ${message}`);\n      messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n      messageArr.push('\\n');\n    }\n    return messageArr.join('\\n');\n  }\n}\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\nclass PartialFailureError extends Error {\n  constructor(b) {\n    super();\n    const errorObject = b;\n    this.errors = errorObject.errors;\n    this.name = 'PartialFailureError';\n    this.response = errorObject.response;\n    this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);\n  }\n}\nexports.PartialFailureError = PartialFailureError;\nclass Util {\n  constructor() {\n    this.ApiError = ApiError;\n    this.PartialFailureError = PartialFailureError;\n  }\n  /**\n   * No op.\n   *\n   * @example\n   * function doSomething(callback) {\n   *   callback = callback || noop;\n   * }\n   */\n  noop() {}\n  /**\n   * Uniformly process an API response.\n   *\n   * @param {*} err - Error value.\n   * @param {*} resp - Response value.\n   * @param {*} body - Body value.\n   * @param {function} callback - The callback function.\n   */\n  handleResp(err, resp, body, callback) {\n    callback = callback || util.noop;\n    const parsedResp = extend(true, {\n      err: err || null\n    }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));\n    // Assign the parsed body to resp.body, even if { json: false } was passed\n    // as a request option.\n    // We assume that nobody uses the previously unparsed value of resp.body.\n    if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n      parsedResp.resp.body = parsedResp.body;\n    }\n    if (parsedResp.err && resp) {\n      parsedResp.err.response = resp;\n    }\n    callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n  }\n  /**\n   * Sniff an incoming HTTP response message for errors.\n   *\n   * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n   * @return {object} parsedHttpRespMessage - The parsed response.\n   * @param {?error} parsedHttpRespMessage.err - An error detected.\n   * @param {object} parsedHttpRespMessage.resp - The original response object.\n   */\n  parseHttpRespMessage(httpRespMessage) {\n    const parsedHttpRespMessage = {\n      resp: httpRespMessage\n    };\n    if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n      // Unknown error. Format according to ApiError standard.\n      parsedHttpRespMessage.err = new ApiError({\n        errors: new Array(),\n        code: httpRespMessage.statusCode,\n        message: httpRespMessage.statusMessage,\n        response: httpRespMessage\n      });\n    }\n    return parsedHttpRespMessage;\n  }\n  /**\n   * Parse the response body from an HTTP request.\n   *\n   * @param {object} body - The response body.\n   * @return {object} parsedHttpRespMessage - The parsed response.\n   * @param {?error} parsedHttpRespMessage.err - An error detected.\n   * @param {object} parsedHttpRespMessage.body - The original body value provided\n   *     will try to be JSON.parse'd. If it's successful, the parsed value will\n   * be returned here, otherwise the original value and an error will be returned.\n   */\n  parseHttpRespBody(body) {\n    const parsedHttpRespBody = {\n      body\n    };\n    if (typeof body === 'string') {\n      try {\n        parsedHttpRespBody.body = JSON.parse(body);\n      } catch (err) {\n        parsedHttpRespBody.body = body;\n      }\n    }\n    if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n      // Error from JSON API.\n      parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n    }\n    return parsedHttpRespBody;\n  }\n  /**\n   * Take a Duplexify stream, fetch an authenticated connection header, and\n   * create an outgoing writable stream.\n   *\n   * @param {Duplexify} dup - Duplexify stream.\n   * @param {object} options - Configuration object.\n   * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n   * @param {object} options.metadata - Metadata to send at the head of the request.\n   * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n   * @param {string=} options.request.method - Default: \"POST\".\n   * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n   * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n   * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n   */\n  makeWritableStream(dup, options, onComplete) {\n    onComplete = onComplete || util.noop;\n    const writeStream = new ProgressStream();\n    writeStream.on('progress', evt => dup.emit('progress', evt));\n    dup.setWritable(writeStream);\n    const defaultReqOpts = {\n      method: 'POST',\n      qs: {\n        uploadType: 'multipart'\n      },\n      timeout: 0,\n      maxRetries: 0\n    };\n    const metadata = options.metadata || {};\n    const reqOpts = extend(true, defaultReqOpts, options.request, {\n      multipart: [{\n        'Content-Type': 'application/json',\n        body: JSON.stringify(metadata)\n      }, {\n        'Content-Type': metadata.contentType || 'application/octet-stream',\n        body: writeStream\n      }]\n    });\n    options.makeAuthenticatedRequest(reqOpts, {\n      onAuthenticated(err, authenticatedReqOpts) {\n        if (err) {\n          dup.destroy(err);\n          return;\n        }\n        requestDefaults.headers = util._getDefaultHeaders();\n        const request = teeny_request_1.teenyRequest.defaults(requestDefaults);\n        request(authenticatedReqOpts, (err, resp, body) => {\n          util.handleResp(err, resp, body, (err, data) => {\n            if (err) {\n              dup.destroy(err);\n              return;\n            }\n            dup.emit('response', resp);\n            onComplete(data);\n          });\n        });\n      }\n    });\n  }\n  /**\n   * Returns true if the API request should be retried, given the error that was\n   * given the first time the request was attempted. This is used for rate limit\n   * related errors as well as intermittent server errors.\n   *\n   * @param {error} err - The API error to check if it is appropriate to retry.\n   * @return {boolean} True if the API request should be retried, false otherwise.\n   */\n  shouldRetryRequest(err) {\n    if (err) {\n      if ([408, 429, 500, 502, 503, 504].indexOf(err.code) !== -1) {\n        return true;\n      }\n      if (err.errors) {\n        for (const e of err.errors) {\n          const reason = e.reason;\n          if (reason === 'rateLimitExceeded') {\n            return true;\n          }\n          if (reason === 'userRateLimitExceeded') {\n            return true;\n          }\n          if (reason && reason.includes('EAI_AGAIN')) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n  /**\n   * Get a function for making authenticated requests.\n   *\n   * @param {object} config - Configuration object.\n   * @param {boolean=} config.autoRetry - Automatically retry requests if the\n   *     response is related to rate limits or certain intermittent server\n   * errors. We will exponentially backoff subsequent requests by default.\n   * (default: true)\n   * @param {object=} config.credentials - Credentials object.\n   * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n   * @param {boolean=} config.useAuthWithCustomEndpoint - If true, will authenticate when using a custom endpoint. Default: false.\n   * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n   * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n   * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n   * @param {array} config.scopes - Array of scopes required for the API.\n   */\n  makeAuthenticatedRequestFactory(config) {\n    const googleAutoAuthConfig = extend({}, config);\n    if (googleAutoAuthConfig.projectId === service_1.DEFAULT_PROJECT_ID_TOKEN) {\n      delete googleAutoAuthConfig.projectId;\n    }\n    let authClient;\n    if (googleAutoAuthConfig.authClient instanceof google_auth_library_1.GoogleAuth) {\n      // Use an existing `GoogleAuth`\n      authClient = googleAutoAuthConfig.authClient;\n    } else {\n      // Pass an `AuthClient` to `GoogleAuth`, if available\n      const config = {\n        ...googleAutoAuthConfig,\n        authClient: googleAutoAuthConfig.authClient\n      };\n      authClient = new google_auth_library_1.GoogleAuth(config);\n    }\n    function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n      let stream;\n      let projectId;\n      const reqConfig = extend({}, config);\n      let activeRequest_;\n      if (!optionsOrCallback) {\n        stream = duplexify();\n        reqConfig.stream = stream;\n      }\n      const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n      const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n      async function setProjectId() {\n        projectId = await authClient.getProjectId();\n      }\n      const onAuthenticated = async (err, authenticatedReqOpts) => {\n        const authLibraryError = err;\n        const autoAuthFailed = err && err.message.indexOf('Could not load the default credentials') > -1;\n        if (autoAuthFailed) {\n          // Even though authentication failed, the API might not actually\n          // care.\n          authenticatedReqOpts = reqOpts;\n        }\n        if (!err || autoAuthFailed) {\n          try {\n            // Try with existing `projectId` value\n            authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n            err = null;\n          } catch (e) {\n            if (e instanceof projectify_1.MissingProjectIdError) {\n              // A `projectId` was required, but we don't have one.\n              try {\n                // Attempt to get the `projectId`\n                await setProjectId();\n                authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n                err = null;\n              } catch (e) {\n                // Re-use the \"Could not load the default credentials error\" if\n                // auto auth failed.\n                err = err || e;\n              }\n            } else {\n              // Some other error unrelated to missing `projectId`\n              err = err || e;\n            }\n          }\n        }\n        if (err) {\n          if (stream) {\n            stream.destroy(err);\n          } else {\n            const fn = options && options.onAuthenticated ? options.onAuthenticated : callback;\n            fn(err);\n          }\n          return;\n        }\n        if (options && options.onAuthenticated) {\n          options.onAuthenticated(null, authenticatedReqOpts);\n        } else {\n          activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, function (apiResponseError) {\n            if (apiResponseError && apiResponseError.code === 401 && authLibraryError) {\n              // Re-use the \"Could not load the default credentials error\" if\n              // the API request failed due to missing credentials.\n              apiResponseError = authLibraryError;\n            }\n            for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n              params[_key - 1] = arguments[_key];\n            }\n            callback(apiResponseError, ...params);\n          });\n        }\n      };\n      const prepareRequest = async () => {\n        try {\n          const getProjectId = async () => {\n            if (config.projectId && config.projectId !== service_1.DEFAULT_PROJECT_ID_TOKEN) {\n              // The user provided a project ID. We don't need to check with the\n              // auth client, it could be incorrect.\n              return config.projectId;\n            }\n            if (config.projectIdRequired === false) {\n              // A projectId is not required. Return the default.\n              return service_1.DEFAULT_PROJECT_ID_TOKEN;\n            }\n            return setProjectId();\n          };\n          const authorizeRequest = async () => {\n            if (reqConfig.customEndpoint && !reqConfig.useAuthWithCustomEndpoint) {\n              // Using a custom API override. Do not use `google-auth-library` for\n              // authentication. (ex: connecting to a local Datastore server)\n              return reqOpts;\n            } else {\n              return authClient.authorizeRequest(reqOpts);\n            }\n          };\n          const [_projectId, authorizedReqOpts] = await Promise.all([getProjectId(), authorizeRequest()]);\n          if (_projectId) {\n            projectId = _projectId;\n          }\n          return onAuthenticated(null, authorizedReqOpts);\n        } catch (e) {\n          return onAuthenticated(e);\n        }\n      };\n      prepareRequest();\n      if (stream) {\n        return stream;\n      }\n      return {\n        abort() {\n          setImmediate(() => {\n            if (activeRequest_) {\n              activeRequest_.abort();\n              activeRequest_ = null;\n            }\n          });\n        }\n      };\n    }\n    const mar = makeAuthenticatedRequest;\n    mar.getCredentials = authClient.getCredentials.bind(authClient);\n    mar.authClient = authClient;\n    return mar;\n  }\n  /**\n   * Make a request through the `retryRequest` module with built-in error\n   * handling and exponential back off.\n   *\n   * @param {object} reqOpts - Request options in the format `request` expects.\n   * @param {object=} config - Configuration object.\n   * @param {boolean=} config.autoRetry - Automatically retry requests if the\n   *     response is related to rate limits or certain intermittent server\n   * errors. We will exponentially backoff subsequent requests by default.\n   * (default: true)\n   * @param {number=} config.maxRetries - Maximum number of automatic retries\n   *     attempted before returning the error. (default: 3)\n   * @param {object=} config.request - HTTP module for request calls.\n   * @param {function} callback - The callback function.\n   */\n  makeRequest(reqOpts, config, callback) {\n    var _a, _b, _c, _d, _e;\n    let autoRetryValue = AUTO_RETRY_DEFAULT;\n    if (config.autoRetry !== undefined) {\n      autoRetryValue = config.autoRetry;\n    } else if (((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.autoRetry) !== undefined) {\n      autoRetryValue = config.retryOptions.autoRetry;\n    }\n    let maxRetryValue = MAX_RETRY_DEFAULT;\n    if (config.maxRetries !== undefined) {\n      maxRetryValue = config.maxRetries;\n    } else if (((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.maxRetries) !== undefined) {\n      maxRetryValue = config.retryOptions.maxRetries;\n    }\n    requestDefaults.headers = this._getDefaultHeaders();\n    const options = {\n      request: teeny_request_1.teenyRequest.defaults(requestDefaults),\n      retries: autoRetryValue !== false ? maxRetryValue : 0,\n      noResponseRetries: autoRetryValue !== false ? maxRetryValue : 0,\n      shouldRetryFn(httpRespMessage) {\n        var _a, _b;\n        const err = util.parseHttpRespMessage(httpRespMessage).err;\n        if ((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.retryableErrorFn) {\n          return err && ((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.retryableErrorFn(err));\n        }\n        return err && util.shouldRetryRequest(err);\n      },\n      maxRetryDelay: (_c = config.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetryDelay,\n      retryDelayMultiplier: (_d = config.retryOptions) === null || _d === void 0 ? void 0 : _d.retryDelayMultiplier,\n      totalTimeout: (_e = config.retryOptions) === null || _e === void 0 ? void 0 : _e.totalTimeout\n    };\n    if (typeof reqOpts.maxRetries === 'number') {\n      options.retries = reqOpts.maxRetries;\n      options.noResponseRetries = reqOpts.maxRetries;\n    }\n    if (!config.stream) {\n      return retryRequest(reqOpts, options,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (err, response, body) => {\n        util.handleResp(err, response, body, callback);\n      });\n    }\n    const dup = config.stream;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let requestStream;\n    const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n    if (isGetRequest) {\n      requestStream = retryRequest(reqOpts, options);\n      dup.setReadable(requestStream);\n    } else {\n      // Streaming writable HTTP requests cannot be retried.\n      requestStream = options.request(reqOpts);\n      dup.setWritable(requestStream);\n    }\n    // Replay the Request events back to the stream.\n    requestStream.on('error', dup.destroy.bind(dup)).on('response', dup.emit.bind(dup, 'response')).on('complete', dup.emit.bind(dup, 'complete'));\n    dup.abort = requestStream.abort;\n    return dup;\n  }\n  /**\n   * Decorate the options about to be made in a request.\n   *\n   * @param {object} reqOpts - The options to be passed to `request`.\n   * @param {string} projectId - The project ID.\n   * @return {object} reqOpts - The decorated reqOpts.\n   */\n  decorateRequest(reqOpts, projectId) {\n    delete reqOpts.autoPaginate;\n    delete reqOpts.autoPaginateVal;\n    delete reqOpts.objectMode;\n    if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n      delete reqOpts.qs.autoPaginate;\n      delete reqOpts.qs.autoPaginateVal;\n      reqOpts.qs = (0, projectify_1.replaceProjectIdToken)(reqOpts.qs, projectId);\n    }\n    if (Array.isArray(reqOpts.multipart)) {\n      reqOpts.multipart = reqOpts.multipart.map(part => {\n        return (0, projectify_1.replaceProjectIdToken)(part, projectId);\n      });\n    }\n    if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n      delete reqOpts.json.autoPaginate;\n      delete reqOpts.json.autoPaginateVal;\n      reqOpts.json = (0, projectify_1.replaceProjectIdToken)(reqOpts.json, projectId);\n    }\n    reqOpts.uri = (0, projectify_1.replaceProjectIdToken)(reqOpts.uri, projectId);\n    return reqOpts;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  isCustomType(unknown, module) {\n    function getConstructorName(obj) {\n      return obj.constructor && obj.constructor.name.toLowerCase();\n    }\n    const moduleNameParts = module.split('/');\n    const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n    const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n    if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n      return false;\n    }\n    let walkingModule = unknown;\n    // eslint-disable-next-line no-constant-condition\n    while (true) {\n      if (getConstructorName(walkingModule) === parentModuleName) {\n        return true;\n      }\n      walkingModule = walkingModule.parent;\n      if (!walkingModule) {\n        return false;\n      }\n    }\n  }\n  /**\n   * Create a properly-formatted User-Agent string from a package.json file.\n   *\n   * @param {object} packageJson - A module's package.json file.\n   * @return {string} userAgent - The formatted User-Agent string.\n   */\n  getUserAgentFromPackageJson(packageJson) {\n    const hyphenatedPackageName = packageJson.name.replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n    .replace('/', '-'); // For UA spec-compliance purposes.\n    return hyphenatedPackageName + '/' + packageJson.version;\n  }\n  /**\n   * Given two parameters, figure out if this is either:\n   *  - Just a callback function\n   *  - An options object, and then a callback function\n   * @param optionsOrCallback An options object or callback.\n   * @param cb A potentially undefined callback.\n   */\n  maybeOptionsOrCallback(optionsOrCallback, cb) {\n    return typeof optionsOrCallback === 'function' ? [{}, optionsOrCallback] : [optionsOrCallback, cb];\n  }\n  _getDefaultHeaders() {\n    return {\n      'User-Agent': util.getUserAgentFromPackageJson(packageJson),\n      'x-goog-api-client': `gl-node/${process.versions.node} gccl/${packageJson.version} gccl-invocation-id/${uuid.v4()}`\n    };\n  }\n}\nexports.Util = Util;\n/**\n * Basic Passthrough Stream that records the number of bytes read\n * every time the cursor is moved.\n */\nclass ProgressStream extends stream_1.Transform {\n  constructor() {\n    super(...arguments);\n    this.bytesRead = 0;\n  }\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  _transform(chunk, encoding, callback) {\n    this.bytesRead += chunk.length;\n    this.emit('progress', {\n      bytesWritten: this.bytesRead,\n      contentLength: '*'\n    });\n    this.push(chunk);\n    callback();\n  }\n}\nconst util = new Util();\nexports.util = util;","map":{"version":3,"names":["Object","defineProperty","exports","value","util","Util","PartialFailureError","ApiError","projectify_1","require","ent","extend","google_auth_library_1","retryRequest","stream_1","teeny_request_1","uuid","service_1","packageJson","duplexify","requestDefaults","timeout","gzip","forever","pool","maxSockets","Infinity","AUTO_RETRY_DEFAULT","MAX_RETRY_DEFAULT","Error","constructor","errorBodyOrMessage","message","errorBody","code","errors","response","JSON","parse","body","error","e","createMultiErrorMessage","captureStackTrace","err","messages","Set","add","length","forEach","decode","toString","messageArr","Array","from","map","i","unshift","push","join","b","errorObject","name","noop","handleResp","resp","callback","parsedResp","parseHttpRespMessage","parseHttpRespBody","httpRespMessage","parsedHttpRespMessage","statusCode","statusMessage","parsedHttpRespBody","makeWritableStream","dup","options","onComplete","writeStream","ProgressStream","on","evt","emit","setWritable","defaultReqOpts","method","qs","uploadType","maxRetries","metadata","reqOpts","request","multipart","stringify","contentType","makeAuthenticatedRequest","onAuthenticated","authenticatedReqOpts","destroy","headers","_getDefaultHeaders","teenyRequest","defaults","data","shouldRetryRequest","indexOf","reason","includes","makeAuthenticatedRequestFactory","config","googleAutoAuthConfig","projectId","DEFAULT_PROJECT_ID_TOKEN","authClient","GoogleAuth","optionsOrCallback","stream","reqConfig","activeRequest_","undefined","setProjectId","getProjectId","authLibraryError","autoAuthFailed","decorateRequest","MissingProjectIdError","fn","makeRequest","apiResponseError","params","prepareRequest","projectIdRequired","authorizeRequest","customEndpoint","useAuthWithCustomEndpoint","_projectId","authorizedReqOpts","Promise","all","abort","setImmediate","mar","getCredentials","bind","_a","_b","_c","_d","_e","autoRetryValue","autoRetry","retryOptions","maxRetryValue","retries","noResponseRetries","shouldRetryFn","retryableErrorFn","maxRetryDelay","retryDelayMultiplier","totalTimeout","requestStream","isGetRequest","toUpperCase","setReadable","autoPaginate","autoPaginateVal","objectMode","replaceProjectIdToken","isArray","part","json","uri","isCustomType","unknown","module","getConstructorName","obj","toLowerCase","moduleNameParts","split","parentModuleName","subModuleName","walkingModule","parent","getUserAgentFromPackageJson","hyphenatedPackageName","replace","version","maybeOptionsOrCallback","cb","process","versions","node","v4","Transform","arguments","bytesRead","_transform","chunk","encoding","bytesWritten","contentLength"],"sources":["/home/yusuf/coding/portfolio/node_modules/@google-cloud/storage/build/src/nodejs-common/util.js"],"sourcesContent":["\"use strict\";\n/*!\n * Copyright 2022 Google LLC. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.util = exports.Util = exports.PartialFailureError = exports.ApiError = void 0;\n/*!\n * @module common/util\n */\nconst projectify_1 = require(\"@google-cloud/projectify\");\nconst ent = require(\"ent\");\nconst extend = require(\"extend\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst retryRequest = require(\"retry-request\");\nconst stream_1 = require(\"stream\");\nconst teeny_request_1 = require(\"teeny-request\");\nconst uuid = require(\"uuid\");\nconst service_1 = require(\"./service\");\nconst packageJson = require('../../../package.json');\n// eslint-disable-next-line @typescript-eslint/no-var-requires\nconst duplexify = require('duplexify');\nconst requestDefaults = {\n    timeout: 60000,\n    gzip: true,\n    forever: true,\n    pool: {\n        maxSockets: Infinity,\n    },\n};\n/**\n * Default behavior: Automatically retry retriable server errors.\n *\n * @const {boolean}\n * @private\n */\nconst AUTO_RETRY_DEFAULT = true;\n/**\n * Default behavior: Only attempt to retry retriable errors 3 times.\n *\n * @const {number}\n * @private\n */\nconst MAX_RETRY_DEFAULT = 3;\n/**\n * Custom error type for API errors.\n *\n * @param {object} errorBody - Error object.\n */\nclass ApiError extends Error {\n    constructor(errorBodyOrMessage) {\n        super();\n        if (typeof errorBodyOrMessage !== 'object') {\n            this.message = errorBodyOrMessage || '';\n            return;\n        }\n        const errorBody = errorBodyOrMessage;\n        this.code = errorBody.code;\n        this.errors = errorBody.errors;\n        this.response = errorBody.response;\n        try {\n            this.errors = JSON.parse(this.response.body).error.errors;\n        }\n        catch (e) {\n            this.errors = errorBody.errors;\n        }\n        this.message = ApiError.createMultiErrorMessage(errorBody, this.errors);\n        Error.captureStackTrace(this);\n    }\n    /**\n     * Pieces together an error message by combining all unique error messages\n     * returned from a single GoogleError\n     *\n     * @private\n     *\n     * @param {GoogleErrorBody} err The original error.\n     * @param {GoogleInnerError[]} [errors] Inner errors, if any.\n     * @returns {string}\n     */\n    static createMultiErrorMessage(err, errors) {\n        const messages = new Set();\n        if (err.message) {\n            messages.add(err.message);\n        }\n        if (errors && errors.length) {\n            errors.forEach(({ message }) => messages.add(message));\n        }\n        else if (err.response && err.response.body) {\n            messages.add(ent.decode(err.response.body.toString()));\n        }\n        else if (!err.message) {\n            messages.add('A failure occurred during this request.');\n        }\n        let messageArr = Array.from(messages);\n        if (messageArr.length > 1) {\n            messageArr = messageArr.map((message, i) => `    ${i + 1}. ${message}`);\n            messageArr.unshift('Multiple errors occurred during the request. Please see the `errors` array for complete details.\\n');\n            messageArr.push('\\n');\n        }\n        return messageArr.join('\\n');\n    }\n}\nexports.ApiError = ApiError;\n/**\n * Custom error type for partial errors returned from the API.\n *\n * @param {object} b - Error object.\n */\nclass PartialFailureError extends Error {\n    constructor(b) {\n        super();\n        const errorObject = b;\n        this.errors = errorObject.errors;\n        this.name = 'PartialFailureError';\n        this.response = errorObject.response;\n        this.message = ApiError.createMultiErrorMessage(errorObject, this.errors);\n    }\n}\nexports.PartialFailureError = PartialFailureError;\nclass Util {\n    constructor() {\n        this.ApiError = ApiError;\n        this.PartialFailureError = PartialFailureError;\n    }\n    /**\n     * No op.\n     *\n     * @example\n     * function doSomething(callback) {\n     *   callback = callback || noop;\n     * }\n     */\n    noop() { }\n    /**\n     * Uniformly process an API response.\n     *\n     * @param {*} err - Error value.\n     * @param {*} resp - Response value.\n     * @param {*} body - Body value.\n     * @param {function} callback - The callback function.\n     */\n    handleResp(err, resp, body, callback) {\n        callback = callback || util.noop;\n        const parsedResp = extend(true, { err: err || null }, resp && util.parseHttpRespMessage(resp), body && util.parseHttpRespBody(body));\n        // Assign the parsed body to resp.body, even if { json: false } was passed\n        // as a request option.\n        // We assume that nobody uses the previously unparsed value of resp.body.\n        if (!parsedResp.err && resp && typeof parsedResp.body === 'object') {\n            parsedResp.resp.body = parsedResp.body;\n        }\n        if (parsedResp.err && resp) {\n            parsedResp.err.response = resp;\n        }\n        callback(parsedResp.err, parsedResp.body, parsedResp.resp);\n    }\n    /**\n     * Sniff an incoming HTTP response message for errors.\n     *\n     * @param {object} httpRespMessage - An incoming HTTP response message from `request`.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.resp - The original response object.\n     */\n    parseHttpRespMessage(httpRespMessage) {\n        const parsedHttpRespMessage = {\n            resp: httpRespMessage,\n        };\n        if (httpRespMessage.statusCode < 200 || httpRespMessage.statusCode > 299) {\n            // Unknown error. Format according to ApiError standard.\n            parsedHttpRespMessage.err = new ApiError({\n                errors: new Array(),\n                code: httpRespMessage.statusCode,\n                message: httpRespMessage.statusMessage,\n                response: httpRespMessage,\n            });\n        }\n        return parsedHttpRespMessage;\n    }\n    /**\n     * Parse the response body from an HTTP request.\n     *\n     * @param {object} body - The response body.\n     * @return {object} parsedHttpRespMessage - The parsed response.\n     * @param {?error} parsedHttpRespMessage.err - An error detected.\n     * @param {object} parsedHttpRespMessage.body - The original body value provided\n     *     will try to be JSON.parse'd. If it's successful, the parsed value will\n     * be returned here, otherwise the original value and an error will be returned.\n     */\n    parseHttpRespBody(body) {\n        const parsedHttpRespBody = {\n            body,\n        };\n        if (typeof body === 'string') {\n            try {\n                parsedHttpRespBody.body = JSON.parse(body);\n            }\n            catch (err) {\n                parsedHttpRespBody.body = body;\n            }\n        }\n        if (parsedHttpRespBody.body && parsedHttpRespBody.body.error) {\n            // Error from JSON API.\n            parsedHttpRespBody.err = new ApiError(parsedHttpRespBody.body.error);\n        }\n        return parsedHttpRespBody;\n    }\n    /**\n     * Take a Duplexify stream, fetch an authenticated connection header, and\n     * create an outgoing writable stream.\n     *\n     * @param {Duplexify} dup - Duplexify stream.\n     * @param {object} options - Configuration object.\n     * @param {module:common/connection} options.connection - A connection instance used to get a token with and send the request through.\n     * @param {object} options.metadata - Metadata to send at the head of the request.\n     * @param {object} options.request - Request object, in the format of a standard Node.js http.request() object.\n     * @param {string=} options.request.method - Default: \"POST\".\n     * @param {string=} options.request.qs.uploadType - Default: \"multipart\".\n     * @param {string=} options.streamContentType - Default: \"application/octet-stream\".\n     * @param {function} onComplete - Callback, executed after the writable Request stream has completed.\n     */\n    makeWritableStream(dup, options, onComplete) {\n        onComplete = onComplete || util.noop;\n        const writeStream = new ProgressStream();\n        writeStream.on('progress', evt => dup.emit('progress', evt));\n        dup.setWritable(writeStream);\n        const defaultReqOpts = {\n            method: 'POST',\n            qs: {\n                uploadType: 'multipart',\n            },\n            timeout: 0,\n            maxRetries: 0,\n        };\n        const metadata = options.metadata || {};\n        const reqOpts = extend(true, defaultReqOpts, options.request, {\n            multipart: [\n                {\n                    'Content-Type': 'application/json',\n                    body: JSON.stringify(metadata),\n                },\n                {\n                    'Content-Type': metadata.contentType || 'application/octet-stream',\n                    body: writeStream,\n                },\n            ],\n        });\n        options.makeAuthenticatedRequest(reqOpts, {\n            onAuthenticated(err, authenticatedReqOpts) {\n                if (err) {\n                    dup.destroy(err);\n                    return;\n                }\n                requestDefaults.headers = util._getDefaultHeaders();\n                const request = teeny_request_1.teenyRequest.defaults(requestDefaults);\n                request(authenticatedReqOpts, (err, resp, body) => {\n                    util.handleResp(err, resp, body, (err, data) => {\n                        if (err) {\n                            dup.destroy(err);\n                            return;\n                        }\n                        dup.emit('response', resp);\n                        onComplete(data);\n                    });\n                });\n            },\n        });\n    }\n    /**\n     * Returns true if the API request should be retried, given the error that was\n     * given the first time the request was attempted. This is used for rate limit\n     * related errors as well as intermittent server errors.\n     *\n     * @param {error} err - The API error to check if it is appropriate to retry.\n     * @return {boolean} True if the API request should be retried, false otherwise.\n     */\n    shouldRetryRequest(err) {\n        if (err) {\n            if ([408, 429, 500, 502, 503, 504].indexOf(err.code) !== -1) {\n                return true;\n            }\n            if (err.errors) {\n                for (const e of err.errors) {\n                    const reason = e.reason;\n                    if (reason === 'rateLimitExceeded') {\n                        return true;\n                    }\n                    if (reason === 'userRateLimitExceeded') {\n                        return true;\n                    }\n                    if (reason && reason.includes('EAI_AGAIN')) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n    /**\n     * Get a function for making authenticated requests.\n     *\n     * @param {object} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {object=} config.credentials - Credentials object.\n     * @param {boolean=} config.customEndpoint - If true, just return the provided request options. Default: false.\n     * @param {boolean=} config.useAuthWithCustomEndpoint - If true, will authenticate when using a custom endpoint. Default: false.\n     * @param {string=} config.email - Account email address, required for PEM/P12 usage.\n     * @param {number=} config.maxRetries - Maximum number of automatic retries attempted before returning the error. (default: 3)\n     * @param {string=} config.keyFile - Path to a .json, .pem, or .p12 keyfile.\n     * @param {array} config.scopes - Array of scopes required for the API.\n     */\n    makeAuthenticatedRequestFactory(config) {\n        const googleAutoAuthConfig = extend({}, config);\n        if (googleAutoAuthConfig.projectId === service_1.DEFAULT_PROJECT_ID_TOKEN) {\n            delete googleAutoAuthConfig.projectId;\n        }\n        let authClient;\n        if (googleAutoAuthConfig.authClient instanceof google_auth_library_1.GoogleAuth) {\n            // Use an existing `GoogleAuth`\n            authClient = googleAutoAuthConfig.authClient;\n        }\n        else {\n            // Pass an `AuthClient` to `GoogleAuth`, if available\n            const config = {\n                ...googleAutoAuthConfig,\n                authClient: googleAutoAuthConfig.authClient,\n            };\n            authClient = new google_auth_library_1.GoogleAuth(config);\n        }\n        function makeAuthenticatedRequest(reqOpts, optionsOrCallback) {\n            let stream;\n            let projectId;\n            const reqConfig = extend({}, config);\n            let activeRequest_;\n            if (!optionsOrCallback) {\n                stream = duplexify();\n                reqConfig.stream = stream;\n            }\n            const options = typeof optionsOrCallback === 'object' ? optionsOrCallback : undefined;\n            const callback = typeof optionsOrCallback === 'function' ? optionsOrCallback : undefined;\n            async function setProjectId() {\n                projectId = await authClient.getProjectId();\n            }\n            const onAuthenticated = async (err, authenticatedReqOpts) => {\n                const authLibraryError = err;\n                const autoAuthFailed = err &&\n                    err.message.indexOf('Could not load the default credentials') > -1;\n                if (autoAuthFailed) {\n                    // Even though authentication failed, the API might not actually\n                    // care.\n                    authenticatedReqOpts = reqOpts;\n                }\n                if (!err || autoAuthFailed) {\n                    try {\n                        // Try with existing `projectId` value\n                        authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n                        err = null;\n                    }\n                    catch (e) {\n                        if (e instanceof projectify_1.MissingProjectIdError) {\n                            // A `projectId` was required, but we don't have one.\n                            try {\n                                // Attempt to get the `projectId`\n                                await setProjectId();\n                                authenticatedReqOpts = util.decorateRequest(authenticatedReqOpts, projectId);\n                                err = null;\n                            }\n                            catch (e) {\n                                // Re-use the \"Could not load the default credentials error\" if\n                                // auto auth failed.\n                                err = err || e;\n                            }\n                        }\n                        else {\n                            // Some other error unrelated to missing `projectId`\n                            err = err || e;\n                        }\n                    }\n                }\n                if (err) {\n                    if (stream) {\n                        stream.destroy(err);\n                    }\n                    else {\n                        const fn = options && options.onAuthenticated\n                            ? options.onAuthenticated\n                            : callback;\n                        fn(err);\n                    }\n                    return;\n                }\n                if (options && options.onAuthenticated) {\n                    options.onAuthenticated(null, authenticatedReqOpts);\n                }\n                else {\n                    activeRequest_ = util.makeRequest(authenticatedReqOpts, reqConfig, (apiResponseError, ...params) => {\n                        if (apiResponseError &&\n                            apiResponseError.code === 401 &&\n                            authLibraryError) {\n                            // Re-use the \"Could not load the default credentials error\" if\n                            // the API request failed due to missing credentials.\n                            apiResponseError = authLibraryError;\n                        }\n                        callback(apiResponseError, ...params);\n                    });\n                }\n            };\n            const prepareRequest = async () => {\n                try {\n                    const getProjectId = async () => {\n                        if (config.projectId &&\n                            config.projectId !== service_1.DEFAULT_PROJECT_ID_TOKEN) {\n                            // The user provided a project ID. We don't need to check with the\n                            // auth client, it could be incorrect.\n                            return config.projectId;\n                        }\n                        if (config.projectIdRequired === false) {\n                            // A projectId is not required. Return the default.\n                            return service_1.DEFAULT_PROJECT_ID_TOKEN;\n                        }\n                        return setProjectId();\n                    };\n                    const authorizeRequest = async () => {\n                        if (reqConfig.customEndpoint &&\n                            !reqConfig.useAuthWithCustomEndpoint) {\n                            // Using a custom API override. Do not use `google-auth-library` for\n                            // authentication. (ex: connecting to a local Datastore server)\n                            return reqOpts;\n                        }\n                        else {\n                            return authClient.authorizeRequest(reqOpts);\n                        }\n                    };\n                    const [_projectId, authorizedReqOpts] = await Promise.all([\n                        getProjectId(),\n                        authorizeRequest(),\n                    ]);\n                    if (_projectId) {\n                        projectId = _projectId;\n                    }\n                    return onAuthenticated(null, authorizedReqOpts);\n                }\n                catch (e) {\n                    return onAuthenticated(e);\n                }\n            };\n            prepareRequest();\n            if (stream) {\n                return stream;\n            }\n            return {\n                abort() {\n                    setImmediate(() => {\n                        if (activeRequest_) {\n                            activeRequest_.abort();\n                            activeRequest_ = null;\n                        }\n                    });\n                },\n            };\n        }\n        const mar = makeAuthenticatedRequest;\n        mar.getCredentials = authClient.getCredentials.bind(authClient);\n        mar.authClient = authClient;\n        return mar;\n    }\n    /**\n     * Make a request through the `retryRequest` module with built-in error\n     * handling and exponential back off.\n     *\n     * @param {object} reqOpts - Request options in the format `request` expects.\n     * @param {object=} config - Configuration object.\n     * @param {boolean=} config.autoRetry - Automatically retry requests if the\n     *     response is related to rate limits or certain intermittent server\n     * errors. We will exponentially backoff subsequent requests by default.\n     * (default: true)\n     * @param {number=} config.maxRetries - Maximum number of automatic retries\n     *     attempted before returning the error. (default: 3)\n     * @param {object=} config.request - HTTP module for request calls.\n     * @param {function} callback - The callback function.\n     */\n    makeRequest(reqOpts, config, callback) {\n        var _a, _b, _c, _d, _e;\n        let autoRetryValue = AUTO_RETRY_DEFAULT;\n        if (config.autoRetry !== undefined) {\n            autoRetryValue = config.autoRetry;\n        }\n        else if (((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.autoRetry) !== undefined) {\n            autoRetryValue = config.retryOptions.autoRetry;\n        }\n        let maxRetryValue = MAX_RETRY_DEFAULT;\n        if (config.maxRetries !== undefined) {\n            maxRetryValue = config.maxRetries;\n        }\n        else if (((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.maxRetries) !== undefined) {\n            maxRetryValue = config.retryOptions.maxRetries;\n        }\n        requestDefaults.headers = this._getDefaultHeaders();\n        const options = {\n            request: teeny_request_1.teenyRequest.defaults(requestDefaults),\n            retries: autoRetryValue !== false ? maxRetryValue : 0,\n            noResponseRetries: autoRetryValue !== false ? maxRetryValue : 0,\n            shouldRetryFn(httpRespMessage) {\n                var _a, _b;\n                const err = util.parseHttpRespMessage(httpRespMessage).err;\n                if ((_a = config.retryOptions) === null || _a === void 0 ? void 0 : _a.retryableErrorFn) {\n                    return err && ((_b = config.retryOptions) === null || _b === void 0 ? void 0 : _b.retryableErrorFn(err));\n                }\n                return err && util.shouldRetryRequest(err);\n            },\n            maxRetryDelay: (_c = config.retryOptions) === null || _c === void 0 ? void 0 : _c.maxRetryDelay,\n            retryDelayMultiplier: (_d = config.retryOptions) === null || _d === void 0 ? void 0 : _d.retryDelayMultiplier,\n            totalTimeout: (_e = config.retryOptions) === null || _e === void 0 ? void 0 : _e.totalTimeout,\n        };\n        if (typeof reqOpts.maxRetries === 'number') {\n            options.retries = reqOpts.maxRetries;\n            options.noResponseRetries = reqOpts.maxRetries;\n        }\n        if (!config.stream) {\n            return retryRequest(reqOpts, options, \n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            (err, response, body) => {\n                util.handleResp(err, response, body, callback);\n            });\n        }\n        const dup = config.stream;\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        let requestStream;\n        const isGetRequest = (reqOpts.method || 'GET').toUpperCase() === 'GET';\n        if (isGetRequest) {\n            requestStream = retryRequest(reqOpts, options);\n            dup.setReadable(requestStream);\n        }\n        else {\n            // Streaming writable HTTP requests cannot be retried.\n            requestStream = options.request(reqOpts);\n            dup.setWritable(requestStream);\n        }\n        // Replay the Request events back to the stream.\n        requestStream\n            .on('error', dup.destroy.bind(dup))\n            .on('response', dup.emit.bind(dup, 'response'))\n            .on('complete', dup.emit.bind(dup, 'complete'));\n        dup.abort = requestStream.abort;\n        return dup;\n    }\n    /**\n     * Decorate the options about to be made in a request.\n     *\n     * @param {object} reqOpts - The options to be passed to `request`.\n     * @param {string} projectId - The project ID.\n     * @return {object} reqOpts - The decorated reqOpts.\n     */\n    decorateRequest(reqOpts, projectId) {\n        delete reqOpts.autoPaginate;\n        delete reqOpts.autoPaginateVal;\n        delete reqOpts.objectMode;\n        if (reqOpts.qs !== null && typeof reqOpts.qs === 'object') {\n            delete reqOpts.qs.autoPaginate;\n            delete reqOpts.qs.autoPaginateVal;\n            reqOpts.qs = (0, projectify_1.replaceProjectIdToken)(reqOpts.qs, projectId);\n        }\n        if (Array.isArray(reqOpts.multipart)) {\n            reqOpts.multipart = reqOpts.multipart.map(part => {\n                return (0, projectify_1.replaceProjectIdToken)(part, projectId);\n            });\n        }\n        if (reqOpts.json !== null && typeof reqOpts.json === 'object') {\n            delete reqOpts.json.autoPaginate;\n            delete reqOpts.json.autoPaginateVal;\n            reqOpts.json = (0, projectify_1.replaceProjectIdToken)(reqOpts.json, projectId);\n        }\n        reqOpts.uri = (0, projectify_1.replaceProjectIdToken)(reqOpts.uri, projectId);\n        return reqOpts;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    isCustomType(unknown, module) {\n        function getConstructorName(obj) {\n            return obj.constructor && obj.constructor.name.toLowerCase();\n        }\n        const moduleNameParts = module.split('/');\n        const parentModuleName = moduleNameParts[0] && moduleNameParts[0].toLowerCase();\n        const subModuleName = moduleNameParts[1] && moduleNameParts[1].toLowerCase();\n        if (subModuleName && getConstructorName(unknown) !== subModuleName) {\n            return false;\n        }\n        let walkingModule = unknown;\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            if (getConstructorName(walkingModule) === parentModuleName) {\n                return true;\n            }\n            walkingModule = walkingModule.parent;\n            if (!walkingModule) {\n                return false;\n            }\n        }\n    }\n    /**\n     * Create a properly-formatted User-Agent string from a package.json file.\n     *\n     * @param {object} packageJson - A module's package.json file.\n     * @return {string} userAgent - The formatted User-Agent string.\n     */\n    getUserAgentFromPackageJson(packageJson) {\n        const hyphenatedPackageName = packageJson.name\n            .replace('@google-cloud', 'gcloud-node') // For legacy purposes.\n            .replace('/', '-'); // For UA spec-compliance purposes.\n        return hyphenatedPackageName + '/' + packageJson.version;\n    }\n    /**\n     * Given two parameters, figure out if this is either:\n     *  - Just a callback function\n     *  - An options object, and then a callback function\n     * @param optionsOrCallback An options object or callback.\n     * @param cb A potentially undefined callback.\n     */\n    maybeOptionsOrCallback(optionsOrCallback, cb) {\n        return typeof optionsOrCallback === 'function'\n            ? [{}, optionsOrCallback]\n            : [optionsOrCallback, cb];\n    }\n    _getDefaultHeaders() {\n        return {\n            'User-Agent': util.getUserAgentFromPackageJson(packageJson),\n            'x-goog-api-client': `gl-node/${process.versions.node} gccl/${packageJson.version} gccl-invocation-id/${uuid.v4()}`,\n        };\n    }\n}\nexports.Util = Util;\n/**\n * Basic Passthrough Stream that records the number of bytes read\n * every time the cursor is moved.\n */\nclass ProgressStream extends stream_1.Transform {\n    constructor() {\n        super(...arguments);\n        this.bytesRead = 0;\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    _transform(chunk, encoding, callback) {\n        this.bytesRead += chunk.length;\n        this.emit('progress', { bytesWritten: this.bytesRead, contentLength: '*' });\n        this.push(chunk);\n        callback();\n    }\n}\nconst util = new Util();\nexports.util = util;\n//# sourceMappingURL=util.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}