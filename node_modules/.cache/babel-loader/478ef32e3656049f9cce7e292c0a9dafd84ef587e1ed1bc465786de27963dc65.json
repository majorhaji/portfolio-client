{"ast":null,"code":"\"use strict\";\n\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\nconst abort_controller_1 = require(\"abort-controller\");\nconst crypto_1 = require(\"crypto\");\nconst extend = require(\"extend\");\nconst gaxios = require(\"gaxios\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst stream_1 = require(\"stream\");\nconst retry = require(\"async-retry\");\nconst uuid = require(\"uuid\");\nconst NOT_FOUND_STATUS_CODE = 404;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst DEFAULT_API_ENDPOINT_REGEX = /.*\\.googleapis\\.com/;\nconst packageJson = require('../../package.json');\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\nclass Upload extends stream_1.Writable {\n  constructor(cfg) {\n    super();\n    this.numBytesWritten = 0;\n    this.numRetries = 0;\n    this.currentInvocationId = {\n      chunk: uuid.v4(),\n      uri: uuid.v4(),\n      offset: uuid.v4()\n    };\n    this.upstreamChunkBuffer = Buffer.alloc(0);\n    this.chunkBufferEncoding = undefined;\n    this.numChunksReadInRequest = 0;\n    /**\n     * A chunk used for caching the most recent upload chunk.\n     * We should not assume that the server received all bytes sent in the request.\n     *  - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n     */\n    this.lastChunkSent = Buffer.alloc(0);\n    this.upstreamEnded = false;\n    cfg = cfg || {};\n    if (!cfg.bucket || !cfg.file) {\n      throw new Error('A bucket and file name are required');\n    }\n    cfg.authConfig = cfg.authConfig || {};\n    cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control'];\n    this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n    this.apiEndpoint = 'https://storage.googleapis.com';\n    if (cfg.apiEndpoint) {\n      this.apiEndpoint = this.sanitizeEndpoint(cfg.apiEndpoint);\n      if (!DEFAULT_API_ENDPOINT_REGEX.test(cfg.apiEndpoint)) {\n        this.authClient = gaxios;\n      }\n    }\n    this.baseURI = `${this.apiEndpoint}/upload/storage/v1/b`;\n    this.bucket = cfg.bucket;\n    const cacheKeyElements = [cfg.bucket, cfg.file];\n    if (typeof cfg.generation === 'number') {\n      cacheKeyElements.push(`${cfg.generation}`);\n    }\n    this.cacheKey = cacheKeyElements.join('/');\n    this.customRequestOptions = cfg.customRequestOptions || {};\n    this.file = cfg.file;\n    this.generation = cfg.generation;\n    this.kmsKeyName = cfg.kmsKeyName;\n    this.metadata = cfg.metadata || {};\n    this.offset = cfg.offset;\n    this.origin = cfg.origin;\n    this.params = cfg.params || {};\n    this.userProject = cfg.userProject;\n    this.chunkSize = cfg.chunkSize;\n    this.retryOptions = cfg.retryOptions;\n    if (cfg.key) {\n      const base64Key = Buffer.from(cfg.key).toString('base64');\n      this.encryption = {\n        key: base64Key,\n        hash: (0, crypto_1.createHash)('sha256').update(cfg.key).digest('base64')\n      };\n    }\n    this.predefinedAcl = cfg.predefinedAcl;\n    if (cfg.private) this.predefinedAcl = 'private';\n    if (cfg.public) this.predefinedAcl = 'publicRead';\n    const autoRetry = cfg.retryOptions.autoRetry;\n    this.uriProvidedManually = !!cfg.uri;\n    this.uri = cfg.uri;\n    this.numBytesWritten = 0;\n    this.numRetries = 0; // counter for number of retries currently executed\n    if (!autoRetry) {\n      cfg.retryOptions.maxRetries = 0;\n    }\n    this.timeOfFirstRequest = Date.now();\n    const contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;\n    this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n    this.once('writing', () => {\n      if (this.uri) {\n        this.continueUploading();\n      } else {\n        this.createURI(err => {\n          if (err) {\n            return this.destroy(err);\n          }\n          this.startUploading();\n          return;\n        });\n      }\n    });\n  }\n  /**\n   * Prevent 'finish' event until the upload has succeeded.\n   *\n   * @param fireFinishEvent The finish callback\n   */\n  _final() {\n    let fireFinishEvent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};\n    this.upstreamEnded = true;\n    this.once('uploadFinished', fireFinishEvent);\n    process.nextTick(() => {\n      this.emit('upstreamFinished');\n      // it's possible `_write` may not be called - namely for empty object uploads\n      this.emit('writing');\n    });\n  }\n  /**\n   * Handles incoming data from upstream\n   *\n   * @param chunk The chunk to append to the buffer\n   * @param encoding The encoding of the chunk\n   * @param readCallback A callback for when the buffer has been read downstream\n   */\n  _write(chunk, encoding) {\n    let readCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : () => {};\n    // Backwards-compatible event\n    this.emit('writing');\n    this.upstreamChunkBuffer = Buffer.concat([this.upstreamChunkBuffer, typeof chunk === 'string' ? Buffer.from(chunk, encoding) : chunk]);\n    this.chunkBufferEncoding = encoding;\n    this.once('readFromChunkBuffer', readCallback);\n    process.nextTick(() => this.emit('wroteToChunkBuffer'));\n  }\n  /**\n   * Prepends data back to the upstream chunk buffer.\n   *\n   * @param chunk The data to prepend\n   */\n  unshiftChunkBuffer(chunk) {\n    this.upstreamChunkBuffer = Buffer.concat([chunk, this.upstreamChunkBuffer]);\n  }\n  /**\n   * Retrieves data from upstream's buffer.\n   *\n   * @param limit The maximum amount to return from the buffer.\n   * @returns The data requested.\n   */\n  pullFromChunkBuffer(limit) {\n    const chunk = this.upstreamChunkBuffer.slice(0, limit);\n    this.upstreamChunkBuffer = this.upstreamChunkBuffer.slice(limit);\n    // notify upstream we've read from the buffer so it can potentially\n    // send more data down.\n    process.nextTick(() => this.emit('readFromChunkBuffer'));\n    return chunk;\n  }\n  /**\n   * A handler for determining if data is ready to be read from upstream.\n   *\n   * @returns If there will be more chunks to read in the future\n   */\n  async waitForNextChunk() {\n    const willBeMoreChunks = await new Promise(resolve => {\n      // There's data available - it should be digested\n      if (this.upstreamChunkBuffer.byteLength) {\n        return resolve(true);\n      }\n      // The upstream writable ended, we shouldn't expect any more data.\n      if (this.upstreamEnded) {\n        return resolve(false);\n      }\n      // Nothing immediate seems to be determined. We need to prepare some\n      // listeners to determine next steps...\n      const wroteToChunkBufferCallback = () => {\n        removeListeners();\n        return resolve(true);\n      };\n      const upstreamFinishedCallback = () => {\n        removeListeners();\n        // this should be the last chunk, if there's anything there\n        if (this.upstreamChunkBuffer.length) return resolve(true);\n        return resolve(false);\n      };\n      // Remove listeners when we're ready to callback.\n      const removeListeners = () => {\n        this.removeListener('wroteToChunkBuffer', wroteToChunkBufferCallback);\n        this.removeListener('upstreamFinished', upstreamFinishedCallback);\n      };\n      // If there's data recently written it should be digested\n      this.once('wroteToChunkBuffer', wroteToChunkBufferCallback);\n      // If the upstream finishes let's see if there's anything to grab\n      this.once('upstreamFinished', upstreamFinishedCallback);\n    });\n    return willBeMoreChunks;\n  }\n  /**\n   * Reads data from upstream up to the provided `limit`.\n   * Ends when the limit has reached or no data is expected to be pushed from upstream.\n   *\n   * @param limit The most amount of data this iterator should return. `Infinity` by default.\n   * @param oneChunkMode Determines if one, exhaustive chunk is yielded for the iterator\n   */\n  upstreamIterator() {\n    try {\n      var _this = this;\n      let limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Infinity;\n      let oneChunkMode = arguments.length > 1 ? arguments[1] : undefined;\n      return async function* () {\n        let completeChunk = Buffer.alloc(0);\n        // read from upstream chunk buffer\n        while (limit && (await _this.waitForNextChunk())) {\n          // read until end or limit has been reached\n          const chunk = _this.pullFromChunkBuffer(limit);\n          limit -= chunk.byteLength;\n          if (oneChunkMode) {\n            // return 1 chunk at the end of iteration\n            completeChunk = Buffer.concat([completeChunk, chunk]);\n          } else {\n            // return many chunks throughout iteration\n            yield {\n              chunk,\n              encoding: _this.chunkBufferEncoding\n            };\n          }\n        }\n        if (oneChunkMode) {\n          yield {\n            chunk: completeChunk,\n            encoding: _this.chunkBufferEncoding\n          };\n        }\n      }();\n    } catch (e) {\n      return Promise.reject(e);\n    }\n  }\n  createURI(callback) {\n    if (!callback) {\n      return this.createURIAsync();\n    }\n    this.createURIAsync().then(r => callback(null, r), callback);\n  }\n  async createURIAsync() {\n    const metadata = {\n      ...this.metadata\n    };\n    const headers = {};\n    // Delete content length and content type from metadata if they exist.\n    // These are headers and should not be sent as part of the metadata.\n    if (metadata.contentLength) {\n      headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n      delete metadata.contentLength;\n    }\n    if (metadata.contentType) {\n      headers['X-Upload-Content-Type'] = metadata.contentType;\n      delete metadata.contentType;\n    }\n    // Check if headers already exist before creating new ones\n    const reqOpts = {\n      method: 'POST',\n      url: [this.baseURI, this.bucket, 'o'].join('/'),\n      params: Object.assign({\n        name: this.file,\n        uploadType: 'resumable'\n      }, this.params),\n      data: metadata,\n      headers: {\n        'x-goog-api-client': `gl-node/${process.versions.node} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.uri}`,\n        ...headers\n      }\n    };\n    if (metadata.contentLength) {\n      reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n    }\n    if (metadata.contentType) {\n      reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n    }\n    if (typeof this.generation !== 'undefined') {\n      reqOpts.params.ifGenerationMatch = this.generation;\n    }\n    if (this.kmsKeyName) {\n      reqOpts.params.kmsKeyName = this.kmsKeyName;\n    }\n    if (this.predefinedAcl) {\n      reqOpts.params.predefinedAcl = this.predefinedAcl;\n    }\n    if (this.origin) {\n      reqOpts.headers.Origin = this.origin;\n    }\n    const uri = await retry(async bail => {\n      var _a, _b, _c;\n      try {\n        const res = await this.makeRequest(reqOpts);\n        // We have successfully got a URI we can now create a new invocation id\n        this.currentInvocationId.uri = uuid.v4();\n        return res.headers.location;\n      } catch (err) {\n        const e = err;\n        const apiError = {\n          code: (_a = e.response) === null || _a === void 0 ? void 0 : _a.status,\n          name: (_b = e.response) === null || _b === void 0 ? void 0 : _b.statusText,\n          message: (_c = e.response) === null || _c === void 0 ? void 0 : _c.statusText,\n          errors: [{\n            reason: e.code\n          }]\n        };\n        if (this.retryOptions.maxRetries > 0 && this.retryOptions.retryableErrorFn(apiError)) {\n          throw e;\n        } else {\n          return bail(e);\n        }\n      }\n    }, {\n      retries: this.retryOptions.maxRetries,\n      factor: this.retryOptions.retryDelayMultiplier,\n      maxTimeout: this.retryOptions.maxRetryDelay * 1000,\n      maxRetryTime: this.retryOptions.totalTimeout * 1000 //convert to milliseconds\n    });\n\n    this.uri = uri;\n    this.offset = 0;\n    return uri;\n  }\n  async continueUploading() {\n    if (typeof this.offset === 'number') {\n      this.startUploading();\n      return;\n    }\n    await this.getAndSetOffset();\n    this.startUploading();\n  }\n  async startUploading() {\n    const multiChunkMode = !!this.chunkSize;\n    let responseReceived = false;\n    this.numChunksReadInRequest = 0;\n    if (!this.offset) {\n      this.offset = 0;\n    }\n    // Check if the offset (server) is too far behind the current stream\n    if (this.offset < this.numBytesWritten) {\n      const delta = this.numBytesWritten - this.offset;\n      const message = `The offset is lower than the number of bytes written. The server has ${this.offset} bytes and while ${this.numBytesWritten} bytes has been uploaded - thus ${delta} bytes are missing. Stopping as this could result in data loss. Initiate a new upload to continue.`;\n      this.emit('error', new RangeError(message));\n      return;\n    }\n    // Check if we should 'fast-forward' to the relevant data to upload\n    if (this.numBytesWritten < this.offset) {\n      // 'fast-forward' to the byte where we need to upload.\n      // only push data from the byte after the one we left off on\n      const fastForwardBytes = this.offset - this.numBytesWritten;\n      for await (const _chunk of this.upstreamIterator(fastForwardBytes)) {\n        _chunk; // discard the data up until the point we want\n      }\n\n      this.numBytesWritten = this.offset;\n    }\n    let expectedUploadSize = undefined;\n    // Set `expectedUploadSize` to `contentLength - this.numBytesWritten`, if available\n    if (typeof this.contentLength === 'number') {\n      expectedUploadSize = this.contentLength - this.numBytesWritten;\n    }\n    // `expectedUploadSize` should be no more than the `chunkSize`.\n    // It's possible this is the last chunk request for a multiple\n    // chunk upload, thus smaller than the chunk size.\n    if (this.chunkSize) {\n      expectedUploadSize = expectedUploadSize ? Math.min(this.chunkSize, expectedUploadSize) : this.chunkSize;\n    }\n    // A queue for the upstream data\n    const upstreamQueue = this.upstreamIterator(expectedUploadSize, multiChunkMode // multi-chunk mode should return 1 chunk per request\n    );\n    // The primary read stream for this request. This stream retrieves no more\n    // than the exact requested amount from upstream.\n    const requestStream = new stream_1.Readable({\n      read: async () => {\n        // Don't attempt to retrieve data upstream if we already have a response\n        if (responseReceived) requestStream.push(null);\n        const result = await upstreamQueue.next();\n        if (result.value) {\n          this.numChunksReadInRequest++;\n          this.lastChunkSent = result.value.chunk;\n          this.numBytesWritten += result.value.chunk.byteLength;\n          this.emit('progress', {\n            bytesWritten: this.numBytesWritten,\n            contentLength: this.contentLength\n          });\n          requestStream.push(result.value.chunk, result.value.encoding);\n        }\n        if (result.done) {\n          requestStream.push(null);\n        }\n      }\n    });\n    const headers = {\n      'x-goog-api-client': `gl-node/${process.versions.node} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.chunk}`\n    };\n    // If using multiple chunk upload, set appropriate header\n    if (multiChunkMode) {\n      // We need to know how much data is available upstream to set the `Content-Range` header.\n      const oneChunkIterator = this.upstreamIterator(expectedUploadSize, true);\n      const {\n        value\n      } = await oneChunkIterator.next();\n      const bytesToUpload = value.chunk.byteLength;\n      // Important: we want to know if the upstream has ended and the queue is empty before\n      // unshifting data back into the queue. This way we will know if this is the last request or not.\n      const isLastChunkOfUpload = !(await this.waitForNextChunk());\n      // Important: put the data back in the queue for the actual upload iterator\n      this.unshiftChunkBuffer(value.chunk);\n      let totalObjectSize = this.contentLength;\n      if (typeof this.contentLength !== 'number' && isLastChunkOfUpload) {\n        // Let's let the server know this is the last chunk since\n        // we didn't know the content-length beforehand.\n        totalObjectSize = bytesToUpload + this.numBytesWritten;\n      }\n      // `- 1` as the ending byte is inclusive in the request.\n      const endingByte = bytesToUpload + this.numBytesWritten - 1;\n      // `Content-Length` for multiple chunk uploads is the size of the chunk,\n      // not the overall object\n      headers['Content-Length'] = bytesToUpload;\n      headers['Content-Range'] = `bytes ${this.offset}-${endingByte}/${totalObjectSize}`;\n    } else {\n      headers['Content-Range'] = `bytes ${this.offset}-*/${this.contentLength}`;\n    }\n    const reqOpts = {\n      method: 'PUT',\n      url: this.uri,\n      headers,\n      body: requestStream\n    };\n    try {\n      const resp = await this.makeRequestStream(reqOpts);\n      if (resp) {\n        responseReceived = true;\n        this.responseHandler(resp);\n      }\n    } catch (e) {\n      const err = e;\n      if (this.retryOptions.retryableErrorFn(err)) {\n        this.attemptDelayedRetry({\n          status: NaN,\n          data: err\n        });\n        return;\n      }\n      this.destroy(err);\n    }\n  }\n  // Process the API response to look for errors that came in\n  // the response body.\n  responseHandler(resp) {\n    if (resp.data.error) {\n      this.destroy(resp.data.error);\n      return;\n    }\n    // At this point we can safely create a new id for the chunk\n    this.currentInvocationId.chunk = uuid.v4();\n    const shouldContinueWithNextMultiChunkRequest = this.chunkSize && resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE && resp.headers.range;\n    if (shouldContinueWithNextMultiChunkRequest) {\n      // Use the upper value in this header to determine where to start the next chunk.\n      // We should not assume that the server received all bytes sent in the request.\n      // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n      const range = resp.headers.range;\n      this.offset = Number(range.split('-')[1]) + 1;\n      // We should not assume that the server received all bytes sent in the request.\n      // - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n      const missingBytes = this.numBytesWritten - this.offset;\n      if (missingBytes) {\n        const dataToPrependForResending = this.lastChunkSent.slice(-missingBytes);\n        // As multi-chunk uploads send one chunk per request and pulls one\n        // chunk into the pipeline, prepending the missing bytes back should\n        // be fine for the next request.\n        this.unshiftChunkBuffer(dataToPrependForResending);\n        this.numBytesWritten -= missingBytes;\n        this.lastChunkSent = Buffer.alloc(0);\n      }\n      // continue uploading next chunk\n      this.continueUploading();\n    } else if (!this.isSuccessfulResponse(resp.status)) {\n      const err = new Error('Upload failed');\n      err.code = resp.status;\n      err.name = 'Upload failed';\n      if (resp === null || resp === void 0 ? void 0 : resp.data) {\n        err.errors = [resp === null || resp === void 0 ? void 0 : resp.data];\n      }\n      this.destroy(err);\n    } else {\n      // remove the last chunk sent to free memory\n      this.lastChunkSent = Buffer.alloc(0);\n      if (resp && resp.data) {\n        resp.data.size = Number(resp.data.size);\n      }\n      this.emit('metadata', resp.data);\n      // Allow the object (Upload) to continue naturally so the user's\n      // \"finish\" event fires.\n      this.emit('uploadFinished');\n    }\n  }\n  async getAndSetOffset() {\n    const opts = {\n      method: 'PUT',\n      url: this.uri,\n      headers: {\n        'Content-Length': 0,\n        'Content-Range': 'bytes */*',\n        'x-goog-api-client': `gl-node/${process.versions.node} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.offset}`\n      }\n    };\n    try {\n      const resp = await this.makeRequest(opts);\n      // Successfully got the offset we can now create a new offset invocation id\n      this.currentInvocationId.offset = uuid.v4();\n      if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n        if (resp.headers.range) {\n          const range = resp.headers.range;\n          this.offset = Number(range.split('-')[1]) + 1;\n          return;\n        }\n      }\n      this.offset = 0;\n    } catch (e) {\n      const err = e;\n      if (this.retryOptions.retryableErrorFn(err)) {\n        this.attemptDelayedRetry({\n          status: NaN,\n          data: err\n        });\n        return;\n      }\n      this.destroy(err);\n    }\n  }\n  async makeRequest(reqOpts) {\n    if (this.encryption) {\n      reqOpts.headers = reqOpts.headers || {};\n      reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n      reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n      reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n    }\n    if (this.userProject) {\n      reqOpts.params = reqOpts.params || {};\n      reqOpts.params.userProject = this.userProject;\n    }\n    // Let gaxios know we will handle a 308 error code ourselves.\n    reqOpts.validateStatus = status => {\n      return this.isSuccessfulResponse(status) || status === RESUMABLE_INCOMPLETE_STATUS_CODE;\n    };\n    const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n    const res = await this.authClient.request(combinedReqOpts);\n    if (res.data && res.data.error) {\n      throw res.data.error;\n    }\n    return res;\n  }\n  async makeRequestStream(reqOpts) {\n    const controller = new abort_controller_1.default();\n    const errorCallback = () => controller.abort();\n    this.once('error', errorCallback);\n    if (this.userProject) {\n      reqOpts.params = reqOpts.params || {};\n      reqOpts.params.userProject = this.userProject;\n    }\n    reqOpts.signal = controller.signal;\n    reqOpts.validateStatus = () => true;\n    const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n    const res = await this.authClient.request(combinedReqOpts);\n    const successfulRequest = this.onResponse(res);\n    this.removeListener('error', errorCallback);\n    return successfulRequest ? res : null;\n  }\n  /**\n   * @return {bool} is the request good?\n   */\n  onResponse(resp) {\n    if (resp.status !== 200 && this.retryOptions.retryableErrorFn({\n      code: resp.status,\n      message: resp.statusText,\n      name: resp.statusText\n    })) {\n      this.attemptDelayedRetry(resp);\n      return false;\n    }\n    this.emit('response', resp);\n    return true;\n  }\n  /**\n   * @param resp GaxiosResponse object from previous attempt\n   */\n  attemptDelayedRetry(resp) {\n    if (this.numRetries < this.retryOptions.maxRetries) {\n      if (resp.status === NOT_FOUND_STATUS_CODE && this.numChunksReadInRequest === 0) {\n        this.startUploading();\n      } else {\n        const retryDelay = this.getRetryDelay();\n        if (retryDelay <= 0) {\n          this.destroy(new Error(`Retry total time limit exceeded - ${resp.data}`));\n          return;\n        }\n        // Unshift the most recent chunk back in case it's needed for the next\n        // request.\n        this.numBytesWritten -= this.lastChunkSent.byteLength;\n        this.unshiftChunkBuffer(this.lastChunkSent);\n        this.lastChunkSent = Buffer.alloc(0);\n        // We don't know how much data has been received by the server.\n        // `continueUploading` will recheck the offset via `getAndSetOffset`.\n        // If `offset` < `numberBytesReceived` then we will raise a RangeError\n        // as we've streamed too much data that has been missed - this should\n        // not be the case for multi-chunk uploads as `lastChunkSent` is the\n        // body of the entire request.\n        this.offset = undefined;\n        setTimeout(this.continueUploading.bind(this), retryDelay);\n      }\n      this.numRetries++;\n    } else {\n      this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n    }\n  }\n  /**\n   * @returns {number} the amount of time to wait before retrying the request\n   */\n  getRetryDelay() {\n    const randomMs = Math.round(Math.random() * 1000);\n    const waitTime = Math.pow(this.retryOptions.retryDelayMultiplier, this.numRetries) * 1000 + randomMs;\n    const maxAllowableDelayMs = this.retryOptions.totalTimeout * 1000 - (Date.now() - this.timeOfFirstRequest);\n    const maxRetryDelayMs = this.retryOptions.maxRetryDelay * 1000;\n    return Math.min(waitTime, maxRetryDelayMs, maxAllowableDelayMs);\n  }\n  /*\n   * Prepare user-defined API endpoint for compatibility with our API.\n   */\n  sanitizeEndpoint(url) {\n    if (!exports.PROTOCOL_REGEX.test(url)) {\n      url = `https://${url}`;\n    }\n    return url.replace(/\\/+$/, ''); // Remove trailing slashes\n  }\n  /**\n   * Check if a given status code is 2xx\n   *\n   * @param status The status code to check\n   * @returns if the status is 2xx\n   */\n  isSuccessfulResponse(status) {\n    return status >= 200 && status < 300;\n  }\n}\nexports.Upload = Upload;\nfunction upload(cfg) {\n  return new Upload(cfg);\n}\nexports.upload = upload;\nfunction createURI(cfg, callback) {\n  const up = new Upload(cfg);\n  if (!callback) {\n    return up.createURI();\n  }\n  up.createURI().then(r => callback(null, r), callback);\n}\nexports.createURI = createURI;","map":{"version":3,"names":["Object","defineProperty","exports","value","createURI","upload","Upload","PROTOCOL_REGEX","abort_controller_1","require","crypto_1","extend","gaxios","google_auth_library_1","stream_1","retry","uuid","NOT_FOUND_STATUS_CODE","RESUMABLE_INCOMPLETE_STATUS_CODE","DEFAULT_API_ENDPOINT_REGEX","packageJson","Writable","constructor","cfg","numBytesWritten","numRetries","currentInvocationId","chunk","v4","uri","offset","upstreamChunkBuffer","Buffer","alloc","chunkBufferEncoding","undefined","numChunksReadInRequest","lastChunkSent","upstreamEnded","bucket","file","Error","authConfig","scopes","authClient","GoogleAuth","apiEndpoint","sanitizeEndpoint","test","baseURI","cacheKeyElements","generation","push","cacheKey","join","customRequestOptions","kmsKeyName","metadata","origin","params","userProject","chunkSize","retryOptions","key","base64Key","from","toString","encryption","hash","createHash","update","digest","predefinedAcl","private","public","autoRetry","uriProvidedManually","maxRetries","timeOfFirstRequest","Date","now","contentLength","Number","NaN","isNaN","once","continueUploading","err","destroy","startUploading","_final","fireFinishEvent","process","nextTick","emit","_write","encoding","readCallback","concat","unshiftChunkBuffer","pullFromChunkBuffer","limit","slice","waitForNextChunk","willBeMoreChunks","Promise","resolve","byteLength","wroteToChunkBufferCallback","removeListeners","upstreamFinishedCallback","length","removeListener","upstreamIterator","Infinity","oneChunkMode","completeChunk","callback","createURIAsync","then","r","headers","contentType","reqOpts","method","url","assign","name","uploadType","data","versions","node","version","ifGenerationMatch","Origin","bail","_a","_b","_c","res","makeRequest","location","e","apiError","code","response","status","statusText","message","errors","reason","retryableErrorFn","retries","factor","retryDelayMultiplier","maxTimeout","maxRetryDelay","maxRetryTime","totalTimeout","getAndSetOffset","multiChunkMode","responseReceived","delta","RangeError","fastForwardBytes","_chunk","expectedUploadSize","Math","min","upstreamQueue","requestStream","Readable","read","result","next","bytesWritten","done","oneChunkIterator","bytesToUpload","isLastChunkOfUpload","totalObjectSize","endingByte","body","resp","makeRequestStream","responseHandler","attemptDelayedRetry","error","shouldContinueWithNextMultiChunkRequest","range","split","missingBytes","dataToPrependForResending","isSuccessfulResponse","size","opts","validateStatus","combinedReqOpts","request","controller","default","errorCallback","abort","signal","successfulRequest","onResponse","retryDelay","getRetryDelay","setTimeout","bind","randomMs","round","random","waitTime","pow","maxAllowableDelayMs","maxRetryDelayMs","replace","up"],"sources":["/home/yusuf/coding/portfolio/node_modules/@google-cloud/storage/build/src/resumable-upload.js"],"sourcesContent":["\"use strict\";\n// Copyright 2022 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\nconst abort_controller_1 = require(\"abort-controller\");\nconst crypto_1 = require(\"crypto\");\nconst extend = require(\"extend\");\nconst gaxios = require(\"gaxios\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst stream_1 = require(\"stream\");\nconst retry = require(\"async-retry\");\nconst uuid = require(\"uuid\");\nconst NOT_FOUND_STATUS_CODE = 404;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst DEFAULT_API_ENDPOINT_REGEX = /.*\\.googleapis\\.com/;\nconst packageJson = require('../../package.json');\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\nclass Upload extends stream_1.Writable {\n    constructor(cfg) {\n        super();\n        this.numBytesWritten = 0;\n        this.numRetries = 0;\n        this.currentInvocationId = {\n            chunk: uuid.v4(),\n            uri: uuid.v4(),\n            offset: uuid.v4(),\n        };\n        this.upstreamChunkBuffer = Buffer.alloc(0);\n        this.chunkBufferEncoding = undefined;\n        this.numChunksReadInRequest = 0;\n        /**\n         * A chunk used for caching the most recent upload chunk.\n         * We should not assume that the server received all bytes sent in the request.\n         *  - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n         */\n        this.lastChunkSent = Buffer.alloc(0);\n        this.upstreamEnded = false;\n        cfg = cfg || {};\n        if (!cfg.bucket || !cfg.file) {\n            throw new Error('A bucket and file name are required');\n        }\n        cfg.authConfig = cfg.authConfig || {};\n        cfg.authConfig.scopes = [\n            'https://www.googleapis.com/auth/devstorage.full_control',\n        ];\n        this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n        this.apiEndpoint = 'https://storage.googleapis.com';\n        if (cfg.apiEndpoint) {\n            this.apiEndpoint = this.sanitizeEndpoint(cfg.apiEndpoint);\n            if (!DEFAULT_API_ENDPOINT_REGEX.test(cfg.apiEndpoint)) {\n                this.authClient = gaxios;\n            }\n        }\n        this.baseURI = `${this.apiEndpoint}/upload/storage/v1/b`;\n        this.bucket = cfg.bucket;\n        const cacheKeyElements = [cfg.bucket, cfg.file];\n        if (typeof cfg.generation === 'number') {\n            cacheKeyElements.push(`${cfg.generation}`);\n        }\n        this.cacheKey = cacheKeyElements.join('/');\n        this.customRequestOptions = cfg.customRequestOptions || {};\n        this.file = cfg.file;\n        this.generation = cfg.generation;\n        this.kmsKeyName = cfg.kmsKeyName;\n        this.metadata = cfg.metadata || {};\n        this.offset = cfg.offset;\n        this.origin = cfg.origin;\n        this.params = cfg.params || {};\n        this.userProject = cfg.userProject;\n        this.chunkSize = cfg.chunkSize;\n        this.retryOptions = cfg.retryOptions;\n        if (cfg.key) {\n            const base64Key = Buffer.from(cfg.key).toString('base64');\n            this.encryption = {\n                key: base64Key,\n                hash: (0, crypto_1.createHash)('sha256').update(cfg.key).digest('base64'),\n            };\n        }\n        this.predefinedAcl = cfg.predefinedAcl;\n        if (cfg.private)\n            this.predefinedAcl = 'private';\n        if (cfg.public)\n            this.predefinedAcl = 'publicRead';\n        const autoRetry = cfg.retryOptions.autoRetry;\n        this.uriProvidedManually = !!cfg.uri;\n        this.uri = cfg.uri;\n        this.numBytesWritten = 0;\n        this.numRetries = 0; // counter for number of retries currently executed\n        if (!autoRetry) {\n            cfg.retryOptions.maxRetries = 0;\n        }\n        this.timeOfFirstRequest = Date.now();\n        const contentLength = cfg.metadata\n            ? Number(cfg.metadata.contentLength)\n            : NaN;\n        this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n        this.once('writing', () => {\n            if (this.uri) {\n                this.continueUploading();\n            }\n            else {\n                this.createURI(err => {\n                    if (err) {\n                        return this.destroy(err);\n                    }\n                    this.startUploading();\n                    return;\n                });\n            }\n        });\n    }\n    /**\n     * Prevent 'finish' event until the upload has succeeded.\n     *\n     * @param fireFinishEvent The finish callback\n     */\n    _final(fireFinishEvent = () => { }) {\n        this.upstreamEnded = true;\n        this.once('uploadFinished', fireFinishEvent);\n        process.nextTick(() => {\n            this.emit('upstreamFinished');\n            // it's possible `_write` may not be called - namely for empty object uploads\n            this.emit('writing');\n        });\n    }\n    /**\n     * Handles incoming data from upstream\n     *\n     * @param chunk The chunk to append to the buffer\n     * @param encoding The encoding of the chunk\n     * @param readCallback A callback for when the buffer has been read downstream\n     */\n    _write(chunk, encoding, readCallback = () => { }) {\n        // Backwards-compatible event\n        this.emit('writing');\n        this.upstreamChunkBuffer = Buffer.concat([\n            this.upstreamChunkBuffer,\n            typeof chunk === 'string' ? Buffer.from(chunk, encoding) : chunk,\n        ]);\n        this.chunkBufferEncoding = encoding;\n        this.once('readFromChunkBuffer', readCallback);\n        process.nextTick(() => this.emit('wroteToChunkBuffer'));\n    }\n    /**\n     * Prepends data back to the upstream chunk buffer.\n     *\n     * @param chunk The data to prepend\n     */\n    unshiftChunkBuffer(chunk) {\n        this.upstreamChunkBuffer = Buffer.concat([chunk, this.upstreamChunkBuffer]);\n    }\n    /**\n     * Retrieves data from upstream's buffer.\n     *\n     * @param limit The maximum amount to return from the buffer.\n     * @returns The data requested.\n     */\n    pullFromChunkBuffer(limit) {\n        const chunk = this.upstreamChunkBuffer.slice(0, limit);\n        this.upstreamChunkBuffer = this.upstreamChunkBuffer.slice(limit);\n        // notify upstream we've read from the buffer so it can potentially\n        // send more data down.\n        process.nextTick(() => this.emit('readFromChunkBuffer'));\n        return chunk;\n    }\n    /**\n     * A handler for determining if data is ready to be read from upstream.\n     *\n     * @returns If there will be more chunks to read in the future\n     */\n    async waitForNextChunk() {\n        const willBeMoreChunks = await new Promise(resolve => {\n            // There's data available - it should be digested\n            if (this.upstreamChunkBuffer.byteLength) {\n                return resolve(true);\n            }\n            // The upstream writable ended, we shouldn't expect any more data.\n            if (this.upstreamEnded) {\n                return resolve(false);\n            }\n            // Nothing immediate seems to be determined. We need to prepare some\n            // listeners to determine next steps...\n            const wroteToChunkBufferCallback = () => {\n                removeListeners();\n                return resolve(true);\n            };\n            const upstreamFinishedCallback = () => {\n                removeListeners();\n                // this should be the last chunk, if there's anything there\n                if (this.upstreamChunkBuffer.length)\n                    return resolve(true);\n                return resolve(false);\n            };\n            // Remove listeners when we're ready to callback.\n            const removeListeners = () => {\n                this.removeListener('wroteToChunkBuffer', wroteToChunkBufferCallback);\n                this.removeListener('upstreamFinished', upstreamFinishedCallback);\n            };\n            // If there's data recently written it should be digested\n            this.once('wroteToChunkBuffer', wroteToChunkBufferCallback);\n            // If the upstream finishes let's see if there's anything to grab\n            this.once('upstreamFinished', upstreamFinishedCallback);\n        });\n        return willBeMoreChunks;\n    }\n    /**\n     * Reads data from upstream up to the provided `limit`.\n     * Ends when the limit has reached or no data is expected to be pushed from upstream.\n     *\n     * @param limit The most amount of data this iterator should return. `Infinity` by default.\n     * @param oneChunkMode Determines if one, exhaustive chunk is yielded for the iterator\n     */\n    async *upstreamIterator(limit = Infinity, oneChunkMode) {\n        let completeChunk = Buffer.alloc(0);\n        // read from upstream chunk buffer\n        while (limit && (await this.waitForNextChunk())) {\n            // read until end or limit has been reached\n            const chunk = this.pullFromChunkBuffer(limit);\n            limit -= chunk.byteLength;\n            if (oneChunkMode) {\n                // return 1 chunk at the end of iteration\n                completeChunk = Buffer.concat([completeChunk, chunk]);\n            }\n            else {\n                // return many chunks throughout iteration\n                yield {\n                    chunk,\n                    encoding: this.chunkBufferEncoding,\n                };\n            }\n        }\n        if (oneChunkMode) {\n            yield {\n                chunk: completeChunk,\n                encoding: this.chunkBufferEncoding,\n            };\n        }\n    }\n    createURI(callback) {\n        if (!callback) {\n            return this.createURIAsync();\n        }\n        this.createURIAsync().then(r => callback(null, r), callback);\n    }\n    async createURIAsync() {\n        const metadata = { ...this.metadata };\n        const headers = {};\n        // Delete content length and content type from metadata if they exist.\n        // These are headers and should not be sent as part of the metadata.\n        if (metadata.contentLength) {\n            headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n            delete metadata.contentLength;\n        }\n        if (metadata.contentType) {\n            headers['X-Upload-Content-Type'] = metadata.contentType;\n            delete metadata.contentType;\n        }\n        // Check if headers already exist before creating new ones\n        const reqOpts = {\n            method: 'POST',\n            url: [this.baseURI, this.bucket, 'o'].join('/'),\n            params: Object.assign({\n                name: this.file,\n                uploadType: 'resumable',\n            }, this.params),\n            data: metadata,\n            headers: {\n                'x-goog-api-client': `gl-node/${process.versions.node} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.uri}`,\n                ...headers,\n            },\n        };\n        if (metadata.contentLength) {\n            reqOpts.headers['X-Upload-Content-Length'] =\n                metadata.contentLength.toString();\n        }\n        if (metadata.contentType) {\n            reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n        }\n        if (typeof this.generation !== 'undefined') {\n            reqOpts.params.ifGenerationMatch = this.generation;\n        }\n        if (this.kmsKeyName) {\n            reqOpts.params.kmsKeyName = this.kmsKeyName;\n        }\n        if (this.predefinedAcl) {\n            reqOpts.params.predefinedAcl = this.predefinedAcl;\n        }\n        if (this.origin) {\n            reqOpts.headers.Origin = this.origin;\n        }\n        const uri = await retry(async (bail) => {\n            var _a, _b, _c;\n            try {\n                const res = await this.makeRequest(reqOpts);\n                // We have successfully got a URI we can now create a new invocation id\n                this.currentInvocationId.uri = uuid.v4();\n                return res.headers.location;\n            }\n            catch (err) {\n                const e = err;\n                const apiError = {\n                    code: (_a = e.response) === null || _a === void 0 ? void 0 : _a.status,\n                    name: (_b = e.response) === null || _b === void 0 ? void 0 : _b.statusText,\n                    message: (_c = e.response) === null || _c === void 0 ? void 0 : _c.statusText,\n                    errors: [\n                        {\n                            reason: e.code,\n                        },\n                    ],\n                };\n                if (this.retryOptions.maxRetries > 0 &&\n                    this.retryOptions.retryableErrorFn(apiError)) {\n                    throw e;\n                }\n                else {\n                    return bail(e);\n                }\n            }\n        }, {\n            retries: this.retryOptions.maxRetries,\n            factor: this.retryOptions.retryDelayMultiplier,\n            maxTimeout: this.retryOptions.maxRetryDelay * 1000,\n            maxRetryTime: this.retryOptions.totalTimeout * 1000, //convert to milliseconds\n        });\n        this.uri = uri;\n        this.offset = 0;\n        return uri;\n    }\n    async continueUploading() {\n        if (typeof this.offset === 'number') {\n            this.startUploading();\n            return;\n        }\n        await this.getAndSetOffset();\n        this.startUploading();\n    }\n    async startUploading() {\n        const multiChunkMode = !!this.chunkSize;\n        let responseReceived = false;\n        this.numChunksReadInRequest = 0;\n        if (!this.offset) {\n            this.offset = 0;\n        }\n        // Check if the offset (server) is too far behind the current stream\n        if (this.offset < this.numBytesWritten) {\n            const delta = this.numBytesWritten - this.offset;\n            const message = `The offset is lower than the number of bytes written. The server has ${this.offset} bytes and while ${this.numBytesWritten} bytes has been uploaded - thus ${delta} bytes are missing. Stopping as this could result in data loss. Initiate a new upload to continue.`;\n            this.emit('error', new RangeError(message));\n            return;\n        }\n        // Check if we should 'fast-forward' to the relevant data to upload\n        if (this.numBytesWritten < this.offset) {\n            // 'fast-forward' to the byte where we need to upload.\n            // only push data from the byte after the one we left off on\n            const fastForwardBytes = this.offset - this.numBytesWritten;\n            for await (const _chunk of this.upstreamIterator(fastForwardBytes)) {\n                _chunk; // discard the data up until the point we want\n            }\n            this.numBytesWritten = this.offset;\n        }\n        let expectedUploadSize = undefined;\n        // Set `expectedUploadSize` to `contentLength - this.numBytesWritten`, if available\n        if (typeof this.contentLength === 'number') {\n            expectedUploadSize = this.contentLength - this.numBytesWritten;\n        }\n        // `expectedUploadSize` should be no more than the `chunkSize`.\n        // It's possible this is the last chunk request for a multiple\n        // chunk upload, thus smaller than the chunk size.\n        if (this.chunkSize) {\n            expectedUploadSize = expectedUploadSize\n                ? Math.min(this.chunkSize, expectedUploadSize)\n                : this.chunkSize;\n        }\n        // A queue for the upstream data\n        const upstreamQueue = this.upstreamIterator(expectedUploadSize, multiChunkMode // multi-chunk mode should return 1 chunk per request\n        );\n        // The primary read stream for this request. This stream retrieves no more\n        // than the exact requested amount from upstream.\n        const requestStream = new stream_1.Readable({\n            read: async () => {\n                // Don't attempt to retrieve data upstream if we already have a response\n                if (responseReceived)\n                    requestStream.push(null);\n                const result = await upstreamQueue.next();\n                if (result.value) {\n                    this.numChunksReadInRequest++;\n                    this.lastChunkSent = result.value.chunk;\n                    this.numBytesWritten += result.value.chunk.byteLength;\n                    this.emit('progress', {\n                        bytesWritten: this.numBytesWritten,\n                        contentLength: this.contentLength,\n                    });\n                    requestStream.push(result.value.chunk, result.value.encoding);\n                }\n                if (result.done) {\n                    requestStream.push(null);\n                }\n            },\n        });\n        const headers = {\n            'x-goog-api-client': `gl-node/${process.versions.node} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.chunk}`,\n        };\n        // If using multiple chunk upload, set appropriate header\n        if (multiChunkMode) {\n            // We need to know how much data is available upstream to set the `Content-Range` header.\n            const oneChunkIterator = this.upstreamIterator(expectedUploadSize, true);\n            const { value } = await oneChunkIterator.next();\n            const bytesToUpload = value.chunk.byteLength;\n            // Important: we want to know if the upstream has ended and the queue is empty before\n            // unshifting data back into the queue. This way we will know if this is the last request or not.\n            const isLastChunkOfUpload = !(await this.waitForNextChunk());\n            // Important: put the data back in the queue for the actual upload iterator\n            this.unshiftChunkBuffer(value.chunk);\n            let totalObjectSize = this.contentLength;\n            if (typeof this.contentLength !== 'number' && isLastChunkOfUpload) {\n                // Let's let the server know this is the last chunk since\n                // we didn't know the content-length beforehand.\n                totalObjectSize = bytesToUpload + this.numBytesWritten;\n            }\n            // `- 1` as the ending byte is inclusive in the request.\n            const endingByte = bytesToUpload + this.numBytesWritten - 1;\n            // `Content-Length` for multiple chunk uploads is the size of the chunk,\n            // not the overall object\n            headers['Content-Length'] = bytesToUpload;\n            headers['Content-Range'] = `bytes ${this.offset}-${endingByte}/${totalObjectSize}`;\n        }\n        else {\n            headers['Content-Range'] = `bytes ${this.offset}-*/${this.contentLength}`;\n        }\n        const reqOpts = {\n            method: 'PUT',\n            url: this.uri,\n            headers,\n            body: requestStream,\n        };\n        try {\n            const resp = await this.makeRequestStream(reqOpts);\n            if (resp) {\n                responseReceived = true;\n                this.responseHandler(resp);\n            }\n        }\n        catch (e) {\n            const err = e;\n            if (this.retryOptions.retryableErrorFn(err)) {\n                this.attemptDelayedRetry({\n                    status: NaN,\n                    data: err,\n                });\n                return;\n            }\n            this.destroy(err);\n        }\n    }\n    // Process the API response to look for errors that came in\n    // the response body.\n    responseHandler(resp) {\n        if (resp.data.error) {\n            this.destroy(resp.data.error);\n            return;\n        }\n        // At this point we can safely create a new id for the chunk\n        this.currentInvocationId.chunk = uuid.v4();\n        const shouldContinueWithNextMultiChunkRequest = this.chunkSize &&\n            resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE &&\n            resp.headers.range;\n        if (shouldContinueWithNextMultiChunkRequest) {\n            // Use the upper value in this header to determine where to start the next chunk.\n            // We should not assume that the server received all bytes sent in the request.\n            // https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n            const range = resp.headers.range;\n            this.offset = Number(range.split('-')[1]) + 1;\n            // We should not assume that the server received all bytes sent in the request.\n            // - https://cloud.google.com/storage/docs/performing-resumable-uploads#chunked-upload\n            const missingBytes = this.numBytesWritten - this.offset;\n            if (missingBytes) {\n                const dataToPrependForResending = this.lastChunkSent.slice(-missingBytes);\n                // As multi-chunk uploads send one chunk per request and pulls one\n                // chunk into the pipeline, prepending the missing bytes back should\n                // be fine for the next request.\n                this.unshiftChunkBuffer(dataToPrependForResending);\n                this.numBytesWritten -= missingBytes;\n                this.lastChunkSent = Buffer.alloc(0);\n            }\n            // continue uploading next chunk\n            this.continueUploading();\n        }\n        else if (!this.isSuccessfulResponse(resp.status)) {\n            const err = new Error('Upload failed');\n            err.code = resp.status;\n            err.name = 'Upload failed';\n            if (resp === null || resp === void 0 ? void 0 : resp.data) {\n                err.errors = [resp === null || resp === void 0 ? void 0 : resp.data];\n            }\n            this.destroy(err);\n        }\n        else {\n            // remove the last chunk sent to free memory\n            this.lastChunkSent = Buffer.alloc(0);\n            if (resp && resp.data) {\n                resp.data.size = Number(resp.data.size);\n            }\n            this.emit('metadata', resp.data);\n            // Allow the object (Upload) to continue naturally so the user's\n            // \"finish\" event fires.\n            this.emit('uploadFinished');\n        }\n    }\n    async getAndSetOffset() {\n        const opts = {\n            method: 'PUT',\n            url: this.uri,\n            headers: {\n                'Content-Length': 0,\n                'Content-Range': 'bytes */*',\n                'x-goog-api-client': `gl-node/${process.versions.node} gccl/${packageJson.version} gccl-invocation-id/${this.currentInvocationId.offset}`,\n            },\n        };\n        try {\n            const resp = await this.makeRequest(opts);\n            // Successfully got the offset we can now create a new offset invocation id\n            this.currentInvocationId.offset = uuid.v4();\n            if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n                if (resp.headers.range) {\n                    const range = resp.headers.range;\n                    this.offset = Number(range.split('-')[1]) + 1;\n                    return;\n                }\n            }\n            this.offset = 0;\n        }\n        catch (e) {\n            const err = e;\n            if (this.retryOptions.retryableErrorFn(err)) {\n                this.attemptDelayedRetry({\n                    status: NaN,\n                    data: err,\n                });\n                return;\n            }\n            this.destroy(err);\n        }\n    }\n    async makeRequest(reqOpts) {\n        if (this.encryption) {\n            reqOpts.headers = reqOpts.headers || {};\n            reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n            reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n            reqOpts.headers['x-goog-encryption-key-sha256'] =\n                this.encryption.hash.toString();\n        }\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        // Let gaxios know we will handle a 308 error code ourselves.\n        reqOpts.validateStatus = (status) => {\n            return (this.isSuccessfulResponse(status) ||\n                status === RESUMABLE_INCOMPLETE_STATUS_CODE);\n        };\n        const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n        const res = await this.authClient.request(combinedReqOpts);\n        if (res.data && res.data.error) {\n            throw res.data.error;\n        }\n        return res;\n    }\n    async makeRequestStream(reqOpts) {\n        const controller = new abort_controller_1.default();\n        const errorCallback = () => controller.abort();\n        this.once('error', errorCallback);\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        reqOpts.signal = controller.signal;\n        reqOpts.validateStatus = () => true;\n        const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n        const res = await this.authClient.request(combinedReqOpts);\n        const successfulRequest = this.onResponse(res);\n        this.removeListener('error', errorCallback);\n        return successfulRequest ? res : null;\n    }\n    /**\n     * @return {bool} is the request good?\n     */\n    onResponse(resp) {\n        if (resp.status !== 200 &&\n            this.retryOptions.retryableErrorFn({\n                code: resp.status,\n                message: resp.statusText,\n                name: resp.statusText,\n            })) {\n            this.attemptDelayedRetry(resp);\n            return false;\n        }\n        this.emit('response', resp);\n        return true;\n    }\n    /**\n     * @param resp GaxiosResponse object from previous attempt\n     */\n    attemptDelayedRetry(resp) {\n        if (this.numRetries < this.retryOptions.maxRetries) {\n            if (resp.status === NOT_FOUND_STATUS_CODE &&\n                this.numChunksReadInRequest === 0) {\n                this.startUploading();\n            }\n            else {\n                const retryDelay = this.getRetryDelay();\n                if (retryDelay <= 0) {\n                    this.destroy(new Error(`Retry total time limit exceeded - ${resp.data}`));\n                    return;\n                }\n                // Unshift the most recent chunk back in case it's needed for the next\n                // request.\n                this.numBytesWritten -= this.lastChunkSent.byteLength;\n                this.unshiftChunkBuffer(this.lastChunkSent);\n                this.lastChunkSent = Buffer.alloc(0);\n                // We don't know how much data has been received by the server.\n                // `continueUploading` will recheck the offset via `getAndSetOffset`.\n                // If `offset` < `numberBytesReceived` then we will raise a RangeError\n                // as we've streamed too much data that has been missed - this should\n                // not be the case for multi-chunk uploads as `lastChunkSent` is the\n                // body of the entire request.\n                this.offset = undefined;\n                setTimeout(this.continueUploading.bind(this), retryDelay);\n            }\n            this.numRetries++;\n        }\n        else {\n            this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n        }\n    }\n    /**\n     * @returns {number} the amount of time to wait before retrying the request\n     */\n    getRetryDelay() {\n        const randomMs = Math.round(Math.random() * 1000);\n        const waitTime = Math.pow(this.retryOptions.retryDelayMultiplier, this.numRetries) *\n            1000 +\n            randomMs;\n        const maxAllowableDelayMs = this.retryOptions.totalTimeout * 1000 -\n            (Date.now() - this.timeOfFirstRequest);\n        const maxRetryDelayMs = this.retryOptions.maxRetryDelay * 1000;\n        return Math.min(waitTime, maxRetryDelayMs, maxAllowableDelayMs);\n    }\n    /*\n     * Prepare user-defined API endpoint for compatibility with our API.\n     */\n    sanitizeEndpoint(url) {\n        if (!exports.PROTOCOL_REGEX.test(url)) {\n            url = `https://${url}`;\n        }\n        return url.replace(/\\/+$/, ''); // Remove trailing slashes\n    }\n    /**\n     * Check if a given status code is 2xx\n     *\n     * @param status The status code to check\n     * @returns if the status is 2xx\n     */\n    isSuccessfulResponse(status) {\n        return status >= 200 && status < 300;\n    }\n}\nexports.Upload = Upload;\nfunction upload(cfg) {\n    return new Upload(cfg);\n}\nexports.upload = upload;\nfunction createURI(cfg, callback) {\n    const up = new Upload(cfg);\n    if (!callback) {\n        return up.createURI();\n    }\n    up.createURI().then(r => callback(null, r), callback);\n}\nexports.createURI = createURI;\n//# sourceMappingURL=resumable-upload.js.map"],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}